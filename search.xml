<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Flask使用MySql数据库</title>
      <link href="/2019/06/14/Flask%E4%BD%BF%E7%94%A8MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/06/14/Flask%E4%BD%BF%E7%94%A8MySql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Centos7 + python3.6 + mysql5.7</span><br></pre></td></tr></table></figure><h2 id="1-安装Flask-SQLAlchemy，pymyql驱动"><a href="#1-安装Flask-SQLAlchemy，pymyql驱动" class="headerlink" title="1.安装Flask-SQLAlchemy，pymyql驱动"></a>1.安装Flask-SQLAlchemy，pymyql驱动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sqlalchemy</span><br><span class="line">pip intall pymysql</span><br></pre></td></tr></table></figure><h2 id="2-使用Flask-SQLAlchemy"><a href="#2-使用Flask-SQLAlchemy" class="headerlink" title="2.使用Flask-SQLAlchemy"></a>2.使用Flask-SQLAlchemy</h2><p>Flask-SQLAlchemy数据库URL<br>常用的数据库引擎：</p><table><thead><tr><th><strong>数据库引擎</strong></th><th><strong>URL</strong></th></tr></thead><tbody><tr><td>MySql</td><td>mysql+pymysql://username:password@host/database</td></tr><tr><td>Postgres</td><td>postgresql://username:password@host/database</td></tr></tbody></table><p>app.py编辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入模块</span></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建flask对象</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置flask配置对象中键：SQLALCHEMY_DATABASE_URI</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] = <span class="string">"mysql+pymysql://username:password@hostname/database"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置flask配置对象中键：SQLALCHEMY_COMMIT_TEARDOWN,设置为True,应用会自动在每次请求结束后提交数据库中变动</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_COMMIT_TEARDOWN'</span>] = Ture</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="keyword">True</span></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取SQLAlchemy实例对象，接下来就可以使用对象调用数据</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure><h2 id="3-sqlalchemy列常见参数"><a href="#3-sqlalchemy列常见参数" class="headerlink" title="3.sqlalchemy列常见参数"></a>3.sqlalchemy列常见参数</h2><table><thead><tr><th><strong>选择项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>autoincrement</td><td>True 是否自增</td></tr><tr><td>primary_key</td><td>True 是否是主键</td></tr><tr><td>index</td><td>TRUE 是否是索引</td></tr><tr><td>unique</td><td>True 是否是唯一</td></tr><tr><td>nullable</td><td>True 是否允许字段为空</td></tr><tr><td>default</td><td>默认值</td></tr></tbody></table><h2 id="4-字段类型"><a href="#4-字段类型" class="headerlink" title="4.字段类型"></a>4.字段类型</h2><table><thead><tr><th><strong>类型名称</strong></th><th><strong>python类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Integer</td><td>int</td><td>常规整型，通常为32位</td></tr><tr><td>SmallInteger</td><td>int</td><td>短整型，通常为16位</td></tr><tr><td>BigInteger</td><td>int或long</td><td>精度不受限整型</td></tr><tr><td>Float</td><td>float</td><td>浮点型</td></tr><tr><td>Numeric</td><td>decimal</td><td>定点数</td></tr><tr><td>String</td><td>str</td><td>可变长度字符串</td></tr><tr><td>Text</td><td>str</td><td>可变长度字符串，适合大量文本</td></tr><tr><td>Unicode</td><td>unicode</td><td>可变长度Unicode字符串</td></tr><tr><td>Boolean</td><td>bool</td><td>布尔值</td></tr><tr><td>Date</td><td>datetime.date</td><td>日期类型</td></tr><tr><td>Time</td><td>datetime.time</td><td>时间类型</td></tr><tr><td>DateTime</td><td>datetime.datetime</td><td>日期时间类型</td></tr><tr><td>Interval</td><td>datetime.timedate</td><td>时间间隔</td></tr><tr><td>Enum</td><td>str</td><td>字符列表</td></tr><tr><td>PickleType</td><td>任意Python对象</td><td>自动Pickle序列化</td></tr><tr><td>LargeBinary</td><td>str</td><td>二进制</td></tr></tbody></table><h2 id="5-使用sqlalchemy"><a href="#5-使用sqlalchemy" class="headerlink" title="5.使用sqlalchemy"></a>5.使用sqlalchemy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db</span><br><span class="line"><span class="comment">#创建模型对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">80</span>), unique=<span class="keyword">True</span>, nullable=<span class="keyword">False</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">120</span>), unique=<span class="keyword">True</span>, nullable=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#repr()方法显示一个可读字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'&lt;User %r&gt;'</span> % self.username</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建表</span></span><br><span class="line">db.create_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除表</span></span><br><span class="line">db.drop_all() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.增加记录</span></span><br><span class="line">admin = User(username=<span class="string">'admin'</span>, email=<span class="string">'admin@example.com'</span>)</span><br><span class="line">guest = User(username=<span class="string">'guest'</span>, email=<span class="string">'guest@example.com'</span>)</span><br><span class="line">db.session.add(admin)</span><br><span class="line">db.session.add(guest)</span><br><span class="line">db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查询记录,注意查询返回对象，如果查询不到返回None</span></span><br><span class="line">User.query.all() <span class="comment">#查询所有</span></span><br><span class="line">User.query.filter_by(username=<span class="string">'admin'</span>).first()<span class="comment">#条件查询</span></span><br><span class="line">User.query.order_by(User.username).all()<span class="comment">#排序查询</span></span><br><span class="line">User.query.limit(<span class="number">1</span>).all()<span class="comment">#查询1条</span></span><br><span class="line">User.query.get(<span class="number">4</span>)<span class="comment">#精确查找(参数为主键)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.删除</span></span><br><span class="line">user = User.query.get(<span class="number">4</span>)</span><br><span class="line">db.session.delete(user)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中yield的用法详解</title>
      <link href="/2019/06/05/python%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/06/05/python%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure><p>就这么简单的几行代码就让你明白什么是yield，代码的输出这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="keyword">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><font color="#9400D3" size="5" face="微软雅黑">下面直接解释代码运行顺序，相当于代码单步调试：</font><p>1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，<font color="red" size="3.5" face="微软雅黑">并没有执行赋值给res操作</font>，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，</p><p>4.程序执行print(“<em>“</em>20)，输出20个*</p><p>5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个<font color="red" size="3.5" face="微软雅黑">next程序停止的地方开始执行的</font>，也就是要执行res的赋值操作，<font color="red" size="3.5" face="微软雅黑">这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数）</font>，所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p><font color="#9400D3" size="5" face="微软雅黑">再看一个这个生成器的send函数的例子，这个例子就把上面那个例子的最后一行换掉了:</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量。</p><font color="#9400D3" size="4" face="微软雅黑"><br>第一次使用生成器需要send(None)或者next()唤醒<br>next() 只唤醒yiedl不传递值<br>send() 唤醒yiedl并传递值<br></font>]]></content>
      
      
      
        <tags>
            
            <tag> Python、Flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>企点开放平台接入之消息加解密指南</title>
      <link href="/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>出于安全考虑，第三方开发者服务器在与企点服务器互相传递数据时必须对消息进行加解密（某些事件可能回复时也需要先进行加密）。而通过主调的方式调用接口时则不需要进行加密。</p><p><font color="#9400D3" size="3" face="微软雅黑">当第三方为集成商模式时后台可能会接收到两种类型的消息：</font><br>1、用户没有开发能力或自己不处理，企点推送给用户的消息由第三方代收。此时，消息XML体中，ToUserName（即接收者）为企点的原始ID（可通过《接口说明》中的获取授权方信息接口来获得）。<br>2、企点服务器发送给集成商自身的事件推送（如取消授权通知，Ticket推送等）。此时，消息XML体中没有ToUserName字段，而是AppId字段，即企点服务的AppId。这种系统事件推送通知（现在包括推送component_verify_ticket协议和推送取消授权通知），收到后也需进行解密并且只需直接返回字符串”success”就可以。</p><p><font color="#9400D3" size="3" face="微软雅黑">而当第三方为开发者模式时，则没有上面的第2种消息。</font><br>具体消息加解密的做法是：<br>1、先对接收到的消息进行验证签名，用于验证消息体的正确性，<font color="#9400D3" size="3" face="微软雅黑">验签指引请查看本页末相关文档——服务器配置指引</font><br>2、验签通过之后再对消息进行解密处理，消息解密流程图：<br><img src="/img/消息解密流程图.png"><br>3、提供加解密Demo供参考：<a href="http://api.qidian.qq.com/wiki/images/file/demo.zip" target="_blank" rel="noopener">http://api.qidian.qq.com/wiki/images/file/demo.zip</a></p><p><font color="red" size="3" face="微软雅黑">注意事项：</font><br>1、EncodingAESKey为消息加解密密钥，长度固定为43个字符，从a-z,A-Z,0-9共62个字符中选取。<br>2、出于安全考虑，开放平台网站提供了修改EncodingAESKey的功能（在EncodingAESKey可能泄漏时进行修改），所以建议企点账号保存当前的和上一次的EncodingAESKey，若当前EncodingAESKey解密失败，则尝试用上一次的EncodingAESKey的解密。回包时，用哪个解密成功，则用此哪个加密对应的回包。</p><p><font color="red" size="4" face="微软雅黑">相关文档：</font><br><a href="/2019/04/08/企点开放平台接入之服务器配置指南/">服务器配置接入指引</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>企点开放平台接入服务器配置指南</title>
      <link href="/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1、搭建自己的服务器"><a href="#1、搭建自己的服务器" class="headerlink" title="1、搭建自己的服务器"></a>1、搭建自己的服务器</h2><p>开发者需要建立一个http或者https服务的Demo，包含了验证签名的逻辑，如图：<br><img src="/img/企点验证签名逻辑.png"><br>参数提取php代码示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/* Created by PhpStorm.</span><br><span class="line">* User: Administrator</span><br><span class="line">* Date: 2016/6/28</span><br><span class="line">* Time: 17:28</span><br><span class="line">*/</span><br><span class="line">if(isset($_GET[&apos;signature&apos;]))&#123;</span><br><span class="line">$signature=$_GET[&apos;signature&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;timestamp&apos;]))&#123;</span><br><span class="line">$timestamp=$_GET[&apos;timestamp&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;nonce&apos;]))&#123;</span><br><span class="line">$nonce=$_GET[&apos;nonce&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;echostr&apos;]))&#123;</span><br><span class="line">$echostr=$_GET[&apos;echostr&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$token=&quot;token1&quot;;</span><br><span class="line">$params=array($token,$timestamp,$nonce);</span><br><span class="line">sort($params,SORT_STRING);</span><br><span class="line">$str = implode($params);</span><br><span class="line">$sign = sha1($str);</span><br><span class="line"></span><br><span class="line">if($sign!=$signature)&#123;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">echo $echostr;</span><br></pre></td></tr></table></figure></p><h2 id="2、验证服务"><a href="#2、验证服务" class="headerlink" title="2、验证服务"></a>2、验证服务</h2><p>准备就绪之后开启服务，回到账户中心点击“检测并保存”按钮，如下图，企点后台会向该服务器发送http的get请求，若提示”验证失败”相关, 请认真检查代码或网络链接等。<br><img src="/img/企点后台服务器配置.png"></p><p><font color="red" size="4" face="微软雅黑">注意：<br>服务器地址(URL)校验通过后会存储在企点api后台，后续的事件推送也是请求该地址；区分这2种请求的方法是看http中的request method，服务器签名校验中是GET，事件推送中是POST。事件推送参见消息加解密接入指引</font></p><p><font color="red" size="4" face="微软雅黑">相关文档：</font><br><a href="/2019/04/08/企点开放平台接入之消息加解密指南/">消息加解密接入指引</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>企点开放平台接入指南</title>
      <link href="/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/08/%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>目前使用企点开发平台有两种方式：<font color="#9400D3" size="3" face="微软雅黑">主调</font>和<font color="#9400D3" size="3" face="微软雅黑">回调</font><br>1、主调：是指开发者通过AppId和AppSecret直接调用企点的开放接口，AppId和AppSecret需要注册获得。<br>2、回调：在有些业务场景中需要用到企点的消息推送能力，企点通过http请求开发者服务器将需要的信息推送给对方服务器，并且对方收到消息后需要做出事件回复响应，这种情况称为企点的回调。此过程中的消息传递都要经过加密处理，<font color="#9400D3" size="3" face="微软雅黑">消息加解密接入指引请查看本页末相关文档。</font><br><img src="/img/主调回调.png"></p><h1 id="注册配置"><a href="#注册配置" class="headerlink" title="注册配置"></a>注册配置</h1><p><font color="red" size="4" face="微软雅黑">要使用企点开放平台首先要注册成为开发者。</font><br>1、打开<a href="https://qidian.qq.com/" target="_blank" rel="noopener">企点官网首页</a>，使用管理员QQ登录<br><img src="/img/企点官网登录后台.png"><br>2、进入企业管理的开发配置填写企点开发信息和服务器配置信息，<font color="#9400D3" size="3" face="微软雅黑">服务器配置指引请查看本页末相关文档</font>，配置好后如图：<br><img src="/img/企点账户中心.png"><br>3、配置完成后可自行测试接口调用<br>建议使用Postman进行接口在线调试，Postman下载链接：<a href="https://www.getpostman.com/" target="_blank" rel="noopener">https://www.getpostman.com/</a><br>调用说明：<br>1)、开发配置中的AppId和AppSecret可用于换取接口调用凭证access_token，通过access_token来调用其他Api开放接口。<br>2)、我们post数据目前大部分都是以json数据post方法调用。所以json数据要在body中使用raw格式推送。不能使用form-data,或者x-www-urlencoded, 一定要注意，否则调用接口可能失败。</p><p><font color="red" size="4" face="微软雅黑">相关文档：</font><br><a href="/2019/04/08/企点开放平台接入之服务器配置指南/">服务器配置接入指引</a><br><a href="/2019/04/08/企点开放平台接入之消息加解密指南/">消息加解密接入指引</a><br><a href="#">获取access_token</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>企点自定义传参</title>
      <link href="/2019/03/27/%E4%BC%81%E7%82%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%A0%E5%8F%82/"/>
      <url>/2019/03/27/%E4%BC%81%E7%82%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<font color="red" size="4" face="微软雅黑">首先，我们先来看下预想的效果图：</font><br><img src="/img/旺旺能力预想图.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">从这个图我们可以知道，用户进入会话前的身份信息和从进入会话的产品页都会被收录在会话窗口右侧自定义的页面上，这个客户库页面可以通过<font color="#F00078" size="4" face="微软雅黑">创建聊天窗口右侧自定义页面接口</font>来创建，那么这些信息又是如何收集到的呢？接下来可以通过下面的流程图理解下</font><br><img src="/img/自定义参数流程图.png"><br><font color="#8E8E8E" size="4" face="微软雅黑"><br>1、当带有自定义参数的wpa被C用户点击并且打开会话窗口的时候，企点srv会获取到这些自定义的参数并且把他们推送到商户开发者的后台服务器上；<br>2、商户开发人员利用收集到的参数信息与相应的客户id关联起来并在本地做好对应的存储关系；<br>3、B侧收到消息打开会话窗口，而当B想要知道是什么样的客户进来了，就可以直接点击窗口右侧的自定义客户库页面；<br>4、客户库页面被点击的瞬间企点srv会自动跳转到这个页面并在URL中携带返回给开发者需要的信息（fromUser、toUser、custId等）；<br>5、商户开发人员拿到对应的客户id与之前的本地存储匹配就可以获取到自定义的参数；<br>6、有了自定义的参数就可以去自己的客户系统里面拿取相应的客户信息并且展示在这个客户库页面上<br></font><br><font color="red" size="4" face="微软雅黑">为了更加有效的清楚整个流程，我们做了一个实际的例子：</font><br><font color="#804040" size="4" face="微软雅黑">先通过<font color="#F00078" size="4" face="微软雅黑">自定义传参接口</font>给wpa添加自定义参数，目前支持的自定义参数为：<br>qidian_ex1、qidian_ex2、qidian_ex3、qidian_ex4、qidian_ex5，值的长度不超过64字节。<br>通过API接口或账户中心创建的接待组件，然后在部署接待组件的页面上设置自定义参数</font><br><font color="#8E8E8E" size="4" face="微软雅黑">传参示例：</font><br><img src="/img/wpa自定义参数.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">此页面定义了两个自定的参数：qidian_ex1和qidian_ex2。<br>当点击下面的wpa组件的时候会，开发者服务器会收到相应的event事件推送，并且会把这两个参数携带上推过去</font><br><img src="/img/自定义传参wpa.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">事件推送如下面的图：</font><br><img src="/img/event自定义参数推送.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">接着B侧打开通过<font color="#F00078" size="4" face="微软雅黑">创建聊天窗口右侧自定义页面接口</font>创建的页面TEST，企点会自动跳转到这个TEST页面并在URL参数中返回给商户开发者需要的信息（fromUser、toUser、custId等），toUser指的是客户的openid；如果是网页会话就是个visitorid（如果客户不更换电脑系统和浏览器每个人的visitorid是不会变的），通过toUser就可以与之前的event事件关联起来得到相应的自定义参数。示例图如下：</font><br><img src="/img/右侧Aio页面.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">这样用户从哪个商品页进来和携带了哪些客户信息就可以通过这两个参数去匹配出相应的信息进而展示在右侧自定义页面上，因此就能实现追踪用户来源等信息的能力</font><br><font color="red" size="4" face="微软雅黑">自定义传参实现的需求场景有很多，典型常用的就是在客户登录的情况下与客服会话，客服需要知道是谁进来了，此时在会话窗口右侧自定义页面直接展示客户信息。</font>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>智能客服机器人与企点的对接</title>
      <link href="/2019/03/25/%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%8E%E4%BC%81%E7%82%B9%E7%9A%84%E5%AF%B9%E6%8E%A5/"/>
      <url>/2019/03/25/%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%8E%E4%BC%81%E7%82%B9%E7%9A%84%E5%AF%B9%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<font color="red" size="4" face="微软雅黑">本文将讲解机器人与企点是如何结合应用的，先来看QQ的通路；对于C侧用户来说面对的是一个机器人，因此用户需要指定一个工号来作为机器人的角色统一回复。</font><br><font color="#8E8E8E" size="4" face="微软雅黑">QQ用户、机器人和客服人员这三者之间的关系网如图：</font><br><img src="/img/机器人流程.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">下面来逐步解析整个消息的走向：</font><br><font color="#8E8E8E" size="4" face="微软雅黑">1、当C侧用户通过wpa触点进入后，开始上行消息到机器人工号</font><br><font color="#8E8E8E" size="4" face="微软雅黑">2、上行消息后，企点svr会把消息推送给第三方后台服务，抄送示例图：</font><br><img src="/img/消息抄送.png"><br><font color="#8E8E8E" size="4" face="微软雅黑">3、第三方拿到消息之后，把消息给到机器人处理是否需要转人工</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#8E8E8E" size="4" face="微软雅黑">A、不需要转接人工:</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#8E8E8E" size="4" face="微软雅黑">1、直接通过FAQ问答系统匹配相应的回复给第三方处理</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#8E8E8E" size="4" face="微软雅黑">2、第三方得到机器人的回复后调用企点的<font color="#F00078" size="4" face="微软雅黑">消息发送接口</font>，通过机器人工号将消息下行到C侧用户，如图：</font><br><img src="/img/发送消息.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#8E8E8E" size="4" face="微软雅黑">B、如果需要转人工，那就利用企点的<font color="#F00078" size="4" face="微软雅黑">QQ会话转接接口</font>把会话转到人工客服，由人工来接待</font><br><font color="#005AB5" size="4" face="微软雅黑">这是目前的整体流程，但是还有如下可以优化的细节，我们一起来看下。</font><br><font color="#FF8000" size="4" face="微软雅黑">一、在寻求人工客服的时候，C触及到人工客服B的方式有个特殊的情况：就是并不是通过wpa触点进来，而是直接通过号码搜索或好友聊天的方式跳过机器人直接联系到客服B了，那么这样的话机器人就起不到应有的作用了。虽然这种特殊情况发生的概率极低，但在未来我们也会对相关逻辑进行优化。</font><br><font color="#FF8000" size="4" face="微软雅黑">二、人工接待分配逻辑，在机器人工号转人工客服的时候，QQ会话转接接口的toOpenid参数是一个客服工号，并不能指定接待组；因此这个分配逻辑只能是用户自己来决定，在不久的未来我们也会发布相应的功能接口（截止到2019年4月1日转接接口都还不能做到转接给接待组）</font><br><font color="#FF8000" size="4" face="微软雅黑">三、消息过滤逻辑，因为企点这边所有的消息推送都会推送给第三方后台，为了避免消息错乱重复等问题，第三方开发人员还需要自己制定一个消息过滤逻辑</font><br><font color="#FF8000" size="4" face="微软雅黑">四、为了所有环境下进来的消息都能通过机器人来管控把关，必须把所有相关的wpa接待组件接待人都统一设置为机器人工号独立接待，而且在客服分配溢出及防漏客机制下也要设置机器人工号为唯一紧急接待人</font><p><br></p><font color="red" size="4" face="微软雅黑">WebIm通路与QQ通路情况类似，可以用同一套方法，但webim通路在人工接待分配逻辑这点不同的是可以指定转接到接待组；还有一个就是因为是临时访客会话，所以不存在C不通过wpa组件直接触达B的情况发生。</font>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Docker之Dockerfile</title>
      <link href="/2019/02/26/%E5%AD%A6%E4%B9%A0Docker%E4%B9%8BDockerfile/"/>
      <url>/2019/02/26/%E5%AD%A6%E4%B9%A0Docker%E4%B9%8BDockerfile/</url>
      
        <content type="html"><![CDATA[<font color="black" size="6" face="楷体">组成部分</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 部分| 命令|</span><br><span class="line">| 基础镜像信息| FROM|</span><br><span class="line">| 维护者信息| MAINTAINER|</span><br><span class="line">| 镜像操作指令| RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等|</span><br><span class="line">| 容器启动时执行指令| CMD、ENTRYPOINT|</span><br></pre></td></tr></table></figure><br><br><font color="black" size="6" face="楷体">各命令详解</font><br><font color="#9400D3" size="4" face="楷体">FROM</font><br>指定哪种镜像作为新镜像的基础镜像，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">MAINTAINER</font><br>指明该镜像的作者和其电子邮件，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Zoe.wang &quot;xxxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">RUN</font><br>在新镜像内部执行的命令，比如安装一些软件、配置一些基础环境，可使用\来换行，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &apos;hello docker!&apos; \</span><br><span class="line">    &gt; /usr/local/file.txt</span><br></pre></td></tr></table></figure><br><br>也可以使用exec格式<font color="red">RUN [“executable”, “param1”, “param2”]</font>的命令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</span><br></pre></td></tr></table></figure><br><br>要注意的是，executable是命令，后面的param是参数<br><font color="#9400D3" size="4" face="楷体">COPY</font><br>将主机的文件复制到镜像内，如果目的位置不存在，Docker会自动创建所有需要的目录结构，但是它只是单纯的复制，并不会去做文件提取和解压工作。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY application.yml /etc/springboot/hello-service/src/resources</span><br></pre></td></tr></table></figure><br><br><font color="#FF8000" size="4">注意：需要复制的目录一定要放在Dockerfile文件的同级目录下</font><br><font color="#9400D3" size="4" face="楷体">ADD</font><br>将主机的文件复制到镜像中，跟COPY一样，限制条件和使用方式都一样，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD application.yml /etc/springboot/hello-service/src/resources</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">EXPOSE</font><br>暴露镜像的端口供主机做映射，启动镜像时，使用-P参数来讲镜像端口与宿主机的随机端口做映射。使用方式（可指定多个）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080 </span><br><span class="line">EXPOSE 8081</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">WORKDIR</font><br>在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local</span><br><span class="line">WORKDIR webservice</span><br><span class="line">RUN echo &apos;hello docker&apos; &gt; text.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>最终会在<font color="red">/usr/local/webservice/</font>目录下生成text.txt文件<br><font color="#9400D3" size="4" face="楷体">ONBUILD</font><br>当一个包含ONBUILD命令的镜像被用作其他镜像的基础镜像时(比如用户的镜像需要从某为准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本)，该命令就会执行。<br>如创建镜像image-A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">...</span><br><span class="line">ONBUILD ADD . /var/www</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>然后创建镜像image-B，指定image-A为基础镜像，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>然后在构建image-B的时候，日志上显示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 0 : FROM image-A</span><br><span class="line"># Execting 1 build triggers</span><br><span class="line">Step onbuild-0 : ADD . /var/www</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">USER</font><br>指定该镜像以什么样的用户去执行，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mongo</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">VOLUME</font><br>用来向基于镜像创建的容器添加卷。比如你可以将mongodb镜像中存储数据的data文件指定为主机的某个文件。(容器内部建议不要存储任何数据)<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data/db /data/configdb</span><br></pre></td></tr></table></figure><br><br>注意:<font color="red">VOLUME 主机目录 容器目录</font><br><font color="#9400D3" size="4" face="楷体">CMD</font><br>容器启动时需要执行的命令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><br><br>同样可以使用exec语法，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure><br><br>当有多个CMD的时候，只有最后一个生效。<br><font color="#9400D3" size="4" face="楷体">ENTRYPOINT</font><br>作用和用法和CMD一模一样<br><font color="gray" size="4" face="楷体">CMD和ENTRYPOINT的区别</font><br>敲黑板！！！非常重要<br>一定要注意！<br><br>一定要注意！<br><br>一定要注意<br>CMD的命令会被 docker run 的命令覆盖而ENTRYPOINT不会<br>CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;hello&quot;,&quot;i am&quot;]</span><br><span class="line">CMD [&quot;docker&quot;]</span><br></pre></td></tr></table></figure><br><br>之后启动构建之后的容器<br><br>使用<font color="red">docker run -ti image</font><p>输出<font color="red">“hello i am docker”</font></p><p>使用<font color="red">docker run -ti image world</font></p><p>输出<font color="red">“hello i am world”</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最新稳定万能vip视频解析接口</title>
      <link href="/2019/01/09/%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E4%B8%87%E8%83%BDvip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/01/09/%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E4%B8%87%E8%83%BDvip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="全网解析-支持站点"><a href="#全网解析-支持站点" class="headerlink" title="全网解析 支持站点"></a>全网解析 支持站点</h2><font color="#FF8000" size="3" face="楷体">奇艺视频 腾讯 优酷 土豆 芒果 乐视 搜狐 PPTV 华数TV 风行 咪咕 哔哩哔哩 ACfun 暴风 CCTV CNTV 范特西 9i广场舞 搜狐自媒体 M1905视频 看看视频 27盘 虎牙直播 全民直播 战旗直播 人人视频 爆米花 今日头条 天翼视频 糖豆视频 龙珠视频 快手视频<br>一直播 新浪视频 360小视频 熊猫TV 斗鱼TV 花椒直播 网易公开课 音悦台 秒拍网 美拍网 爱拍 凤凰视频 梨视频 微录客 人民微视频 17173视频 优米视频 m3u8 mp4视频 微博视频 YY视频 私有云资源</font><h5 id="https-cdn-yangju-vip-k-url-后面加上播放的地址即可"><a href="#https-cdn-yangju-vip-k-url-后面加上播放的地址即可" class="headerlink" title="https://cdn.yangju.vip/k/?url=后面加上播放的地址即可"></a><font size="3" face="楷体"><a href="https://cdn.yangju.vip/k/?url=后面加上播放的地址即可" target="_blank" rel="noopener">https://cdn.yangju.vip/k/?url=后面加上播放的地址即可</a></font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.yangju.vip/k/?url=</span><br><span class="line">https://jx.lache.me/cc/?url=</span><br><span class="line">https://api.653520.top/vip/?url=</span><br><span class="line">https://jx.ab33.top/vip/?url=</span><br><span class="line">https://vip.mpos.ren/v/?url=</span><br><span class="line">https://jx.000180.top/jx/?url=</span><br><span class="line">https://jx.km58.top/jx/?url=</span><br><span class="line">https://api.smq1.com/?url=</span><br><span class="line">https://jx.hezeshi.net/ce/jlexi.php?url=</span><br><span class="line">https://www.kkflv.com/?url=    //Btjson智能解析</span><br><span class="line">https://jx.618g.com/?url=    //618G解析</span><br></pre></td></tr></table></figure><h3 id="永久性，重要的是够稳定！而且CDN加速！！解析接口支持-URL模式"><a href="#永久性，重要的是够稳定！而且CDN加速！！解析接口支持-URL模式" class="headerlink" title="永久性，重要的是够稳定！而且CDN加速！！解析接口支持:URL模式"></a>永久性，重要的是够稳定！而且CDN加速！！解析接口支持:URL模式</h3>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Go的cron定时任务用法</title>
      <link href="/2018/12/27/Go%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95/"/>
      <url>/2018/12/27/Go%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="安装第三方库robfig-cron："><a href="#安装第三方库robfig-cron：" class="headerlink" title="安装第三方库robfig/cron："></a>安装第三方库robfig/cron：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/robfig/cron</span><br></pre></td></tr></table></figure><h2 id="应用：-每秒钟执行一次"><a href="#应用：-每秒钟执行一次" class="headerlink" title="应用： 每秒钟执行一次"></a>应用： 每秒钟执行一次</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/robfig/cron&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">i := 0</span><br><span class="line">c := cron.New()</span><br><span class="line">//秒 分 时 日 月 周</span><br><span class="line">spec := &quot;*/1 * * * * *&quot;</span><br><span class="line">c.AddFunc(spec, func() &#123;</span><br><span class="line">i++</span><br><span class="line">log.Println(&quot;execute per second&quot;, i)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line">select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其中注意select的用法：-golang的select的功能和-select-poll-epoll相似。也可以用for-实现"><a href="#其中注意select的用法：-golang的select的功能和-select-poll-epoll相似。也可以用for-实现" class="headerlink" title="其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现"></a>其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现</h2>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go数学运算随机数</title>
      <link href="/2018/11/15/Go%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2018/11/15/Go%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>总是要有使用随机数的情况。这就需要使用math包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math/rand&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Println(&quot;My random number is&quot;,  rand.Intn(200))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上面的代码就会发现每次返回的随机数是不变的。因为运行环境是没有发生变化的。<br>为了每次得到不同的随机数，就需要一个随机数种子。</p><p><font color="#FF8000" size="3" face="宋体">时间是不停的在发生变化的，利用time.Now().UnixNano()获得一个带纳秒的时间戳，<br>形成一个新源。然后随机数就可以有想要的效果了。</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math/rand&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    fmt.Println(&quot;My random number is&quot;, rand.Intn(200))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang的格式化输出</title>
      <link href="/2018/10/11/Golang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>/2018/10/11/Golang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">普通占位符</span><br><span class="line">占位符     说明                           举例                   输出</span><br><span class="line">%v      相应值的默认格式。            Printf(&quot;%v&quot;, people)   &#123;zhangsan&#125;，</span><br><span class="line">%+v     打印结构体时，会添加字段名     Printf(&quot;%+v&quot;, people)  &#123;Name:zhangsan&#125;</span><br><span class="line">%#v     相应值的Go语法表示            Printf(&quot;#v&quot;, people)   main.Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br><span class="line">%T      相应值的类型的Go语法表示       Printf(&quot;%T&quot;, people)   main.Human</span><br><span class="line">%%      字面上的百分号，并非值的占位符  Printf(&quot;%%&quot;)            %</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">布尔占位符</span><br><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf(&quot;%t&quot;, true)       true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数占位符</span><br><span class="line">占位符     说明                                  举例                       输出</span><br><span class="line">%b      二进制表示                             Printf(&quot;%b&quot;, 5)             101</span><br><span class="line">%c      相应Unicode码点所表示的字符              Printf(&quot;%c&quot;, 0x4E2D)        中</span><br><span class="line">%d      十进制表示                             Printf(&quot;%d&quot;, 0x12)          18</span><br><span class="line">%o      八进制表示                             Printf(&quot;%d&quot;, 10)            12</span><br><span class="line">%q      单引号围绕的字符字面值，由Go语法安全地转义 Printf(&quot;%q&quot;, 0x4E2D)        &apos;中&apos;</span><br><span class="line">%x      十六进制表示，字母形式为小写 a-f         Printf(&quot;%x&quot;, 13)             d</span><br><span class="line">%X      十六进制表示，字母形式为大写 A-F         Printf(&quot;%x&quot;, 13)             D</span><br><span class="line">%U      Unicode格式：U+1234，等同于 &quot;U+%04X&quot;   Printf(&quot;%U&quot;, 0x4E2D)         U+4E2D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮点数和复数的组成部分（实部和虚部）</span><br><span class="line">占位符     说明                              举例            输出</span><br><span class="line">%b      无小数部分的，指数为二的幂的科学计数法，</span><br><span class="line">        与 strconv.FormatFloat 的 &apos;b&apos; 转换格式一致。例如 -123456p-78</span><br><span class="line">%e      科学计数法，例如 -1234.456e+78        Printf(&quot;%e&quot;, 10.2)     1.020000e+01</span><br><span class="line">%E      科学计数法，例如 -1234.456E+78        Printf(&quot;%e&quot;, 10.2)     1.020000E+01</span><br><span class="line">%f      有小数点而无指数，例如 123.456        Printf(&quot;%f&quot;, 10.2)     10.200000</span><br><span class="line">%g      根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20)   10.2</span><br><span class="line">%G      根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串与字节切片</span><br><span class="line">占位符     说明                              举例                           输出</span><br><span class="line">%s      输出字符串表示（string类型或[]byte)   Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;))  Go语言</span><br><span class="line">%q      双引号围绕的字符串，由Go语法安全地转义  Printf(&quot;%q&quot;, &quot;Go语言&quot;)         &quot;Go语言&quot;</span><br><span class="line">%x      十六进制，小写字母，每字节两个字符      Printf(&quot;%x&quot;, &quot;golang&quot;)         676f6c616e67</span><br><span class="line">%X      十六进制，大写字母，每字节两个字符      Printf(&quot;%X&quot;, &quot;golang&quot;)         676F6C616E67</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针</span><br><span class="line">占位符         说明                      举例                             输出</span><br><span class="line">%p      十六进制表示，前缀 0x          Printf(&quot;%p&quot;, &amp;people)             0x4f57f0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">其它标记</span><br><span class="line">占位符      说明                             举例          输出</span><br><span class="line">+      总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 </span><br><span class="line">                                           Printf(&quot;%+q&quot;, &quot;中文&quot;)  &quot;\u4e2d\u6587&quot;</span><br><span class="line">-      在右侧而非左侧填充空格（左对齐该区域）</span><br><span class="line">#      备用格式：为八进制添加前导 0（%#o）      Printf(&quot;%#U&quot;, &apos;中&apos;)      U+4E2D</span><br><span class="line">       为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；</span><br><span class="line">       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；</span><br><span class="line">       如果是可打印字符，%U（%#U）会写出该字符的</span><br><span class="line">       Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。</span><br><span class="line">&apos; &apos;    (空格)为数值中省略的正负号留出空白（% d）；</span><br><span class="line">       以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line">0      填充前导的0而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure><font color="#FF8000" size="4" face="微软雅黑"><br>golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。<br><br>宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。<br>操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。<br><br>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。<br><br>%e 和 %f 的默认精度为6<br><br>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。<br><br>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。<br></font>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux awk命令详解</title>
      <link href="/2018/09/25/awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/09/25/awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>默认每行按空格或TAB分割：<code>awk &#39;{print $1,$4}&#39; log.txt</code></p><p>-F,指定分割字符：<code>awk -F : &#39;{print $1,$4}&#39; log.txt</code><br>   指定多个分割字符,先用:分割,然后再用,分割：<code>awk -F &#39;[:,]&#39; &#39;{print $1,$4}&#39; log.txt</code></p><p>-v,指定变量：<code>awk -v a=1 -v b=s &#39;{print $1,$1+a,$1b}&#39; log.txt</code></p><p>-f,调用awk脚本：<code>awk -f script.awk log.txt</code></p><p>//,纯字符匹配：<code>awk &#39;/dockerroot/&#39; /etc/passwd</code></p><p>!//,纯字符不匹配：<code>awk &#39;!/dockerroot/&#39; /etc/passwd</code></p><p>/|/,匹配a1或a2：<code>awk &#39;!/a1|a2/&#39; /etc/passwd</code></p><p>~//,字段值匹配：<code>awk &#39;$1~/root/&#39; /etc/passwd</code></p><p>!~//,字段值不匹配：<code>awk -F : &#39;$1!~/root/&#39; /etc/passwd</code></p><p>IF语句,必须用在{}中，且比较内容用()扩起来if…else…：<br><code>awk -F: &#39;{if($1~/root/) {print $1} else {print $2}}&#39; /etc/passwd</code>            </p><p>逻辑运算符：&amp;&amp;?|| </p><p>条件表达式：==   !=   &gt;   &gt;=  </p><p>while语句：<code>awk -F: &#39;BEGIN{i=1} {while(i&lt;8) print $i,i++}&#39; /etc/passwd</code></p><p>NF、NR：NF代表每行字段数，NR代表行号</p>]]></content>
      
      
      <categories>
          
          <category> Linux世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7.3编译安装go1.8.1</title>
      <link href="/2018/09/25/CentOS7.3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1.8.1/"/>
      <url>/2018/09/25/CentOS7.3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1.8.1/</url>
      
        <content type="html"><![CDATA[<p>go1.8.1下载地址<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>，这里下载go1.8.1.src.tar.gz和go1.4.3.src.tar.gz，下来以后算下md5哈希和官网比对下，以免被加盐；</p><p><font color="red" size="3" face="微软雅黑">go1.4以上版本安装的时候需先安装下1.4；要么会报类似下面的错：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##### Building Go bootstrap tool.</span><br><span class="line">cmd/dist</span><br><span class="line">ERROR: Cannot find /root/go1.4/bin/go.</span><br><span class="line">Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4.</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">开始安装：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc glibc-devel -y</span><br><span class="line">tar -C /root/ -xvf go1.4.3.src.tar.gz</span><br><span class="line">mv /root/go/ /root/go1.4</span><br><span class="line">cd /root/go1.4/src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">约１分钟左右安装完成，设置下环境变量并重新加载</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export PATH=$PATH:/root/go1.4/bin&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export GOROOT=/root/go1.4&quot; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">使用go version查看版本已经是go1.4.3了</font><br><img src="/img/2485282189.png" width="548"></p><p><font color="gray" size="5" face="楷体">开始安装go1.8.1</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local/ -xvf go1.8.1.src.tar.gz</span><br><span class="line">cd /usr/local/go/src/</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">安装完成以后，清除掉之前添加的/etc/profile里面的环境变量信息，增加如下配置</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/go-projects</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">重新加载配置</font><br><code>source /etc/profile</code></p><p><font color="gray" size="5" face="楷体">查看版本go version,已经是1.8.1了</font><br><img src="/img/3683651371.png" height="86"></p><p><font color="gray" size="5" face="楷体">创建go的hello world程序：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存为hello.go<br>直接运行 go run hello.go<br>返回hello，world！</p><p><font color="#FF8000" size="5" face="楷体">至此，go1.8.1安装完毕！</font><br>或者直接使用编译好的包：go1.10.1.linux-amd64.tar.gz<br>下载go<br>$wget <a href="https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz" target="_blank" rel="noopener">https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz</a><br>$tar -xvf go1.10.1.linux-amd64.tar.gz<br>设置环境变量<br>$vim /etc/profile<br>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/data/work/gopath</span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line">export GOROOT=/data/work/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin:$GOBIN</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>$GOPATH工作目录结构，约定有三个子目录（需要自行创建）：<br>src ——存放源代码文件<br>pkg——存放编译后的文件<br>bin ——存放编译后的可执行文件<br>测试环境:<br>创建目录 /data/work/gopath/src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$mkdir helloworld</span><br><span class="line">$cd helloworld</span><br><span class="line">$vim main.go</span><br></pre></td></tr></table></figure></p><p>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux上安装GO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>openresty笔记</title>
      <link href="/2018/09/25/openresty%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/25/openresty%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>–启动命令：/usr/local/openresty/bin/openresty<br>–停止命令：/usr/local/openresty/bin/openresty -s stop<br>–重启命令：/usr/local/openresty/bin/openresty -s reload<br>–检验nginx配置是否正确：/usr/local/openresty/bin/openresty -t</p><p>开发时可以把server里面的location中的 lua_code_cache 设置为 off; 线上不要，代价太大。</p><p>ngx.say() 直接返回请求结果<br>ngx.req.read_body() 获取post body值<br>ngx.req.get_post_args() 获取post参数<br>ngx.req.get_uri_args() 获取url中参数</p><p>一个lua的表函数要有类似C++类函数的this指针（self）<br>用冒号(:)调用函数时，会默认传一个值(self)作为第一个参数;<br>用点(.)调用函数时，则没有；</p><pre><code>连。接。调。用。redis</code></pre><p>redis模块引用：在nginx主配置文件的http部分添加如下配置 ，其中”;;”表示默认搜索路径。<br>lua_package_path “/usr/local/openresty/lualib/resty/?.lua;;”;      #lua 模块<br>lua_package_cpath “yourpath/?.so;;”;                                      #c模块</p><p>local redis = require(“resty.redis”)                           #导入 resty.redis 模块<br>local red = redis:new()                                           #实例化 redis 对象<br>red:set_timeout(1000)                                           #设置超时（毫秒）<br>local ok, err = red:connect(“127.0.0.1”, 6379)         #连接到服务器<br>local ok, err = red:auth(“yourpasswd”)                    #验证（如果要验证）<br>local ok, err = red:set_keepalive(1000, 100)            #将连接添加到连接池中<br>local ok, err = red:set(“dog”, “an animal”)               #redis的set操作<br>local res, err = red:get(“dog”)                                 #redis的get操作<br>red:close()                                                             #关闭连接,如果使用连接池就不需要关闭</p><p>启用连接池需要开启 lua_code_cache on<br>测试连接池时，线程数需要小于set_keepalive中的第二个参数（即连接数）</p>]]></content>
      
      
      <categories>
          
          <category> Linux世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openresty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go操作mysql建表问题的解决办法</title>
      <link href="/2018/09/25/Go%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/09/25/Go%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF8000" size="4" face="楷体">table.sql 文件内容如下</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;,</span><br><span class="line">  `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="4" face="楷体">go 代码如下：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func createTable() (err error) &#123;</span><br><span class="line">    host := &quot;127.0.0.1&quot;</span><br><span class="line">    port := &quot;3306&quot;</span><br><span class="line">    user := &quot;root&quot;</span><br><span class="line">    pass := &quot;admin&quot;</span><br><span class="line">    name := &quot;test&quot;</span><br><span class="line">    sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;);</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    sqlTable := string(sqlBytes);</span><br><span class="line">    fmt.Println(sqlTable)</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">    _, err = db.Exec(sqlTable)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="4" face="楷体">执行，出错：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right </span><br><span class="line">syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>刚开始是以为 sql 语句有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql语句的问题。<br>查找资料才知道原因 默认是不能在同时执行两条 sql 语句的</p><p><font color="#FF8000" size="4" face="楷体">解决办法：</font><br>1.将 多条 sql 语句拆开，每个语句单独执行 db.Exec()<br>2.查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下 (增加了 &amp;multiStatements=true 参数)<br><code></code>db, err := sql.Open(“mysql”, user+”:”+pass+”@tcp(“+host+”:”+port+”)/“+name+”?charset=utf8&amp;multiStatements=true”)</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang操作mysql使用案例</title>
      <link href="/2018/09/25/Golang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/09/25/Golang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;database/sql&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type DbWorker struct &#123;</span><br><span class="line">Dsn      string</span><br><span class="line">Db       *sql.DB</span><br><span class="line">UserInfo userTB</span><br><span class="line">&#125;</span><br><span class="line">type userTB struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name sql.NullString</span><br><span class="line">Age  sql.NullInt64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var err error</span><br><span class="line">dbw := DbWorker&#123;</span><br><span class="line">Dsn: &quot;root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4&quot;,</span><br><span class="line">&#125;</span><br><span class="line">dbw.Db, err = sql.Open(&quot;mysql&quot;, dbw.Dsn)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dbw.Db.Close()</span><br><span class="line"></span><br><span class="line">dbw.insertData()</span><br><span class="line">dbw.queryData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dbw *DbWorker) insertData() &#123;</span><br><span class="line">stmt, _ := dbw.Db.Prepare(`INSERT INTO user (name, age) VALUES (?, ?)`)</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">ret, err := stmt.Exec(&quot;xys&quot;, 23)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;insert data error: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if LastInsertId, err := ret.LastInsertId(); nil == err &#123;</span><br><span class="line">fmt.Println(&quot;LastInsertId:&quot;, LastInsertId)</span><br><span class="line">&#125;</span><br><span class="line">if RowsAffected, err := ret.RowsAffected(); nil == err &#123;</span><br><span class="line">fmt.Println(&quot;RowsAffected:&quot;, RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dbw *DbWorker) QueryDataPre() &#123;</span><br><span class="line">dbw.UserInfo = userTB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">func (dbw *DbWorker) queryData() &#123;</span><br><span class="line">stmt, _ := dbw.Db.Prepare(`SELECT * From user where age &gt;= ? AND age &lt; ?`)</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">dbw.QueryDataPre()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(20, 30)</span><br><span class="line">defer rows.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;insert data error: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">dbw.UserInfo.Name.String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">if !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">dbw.UserInfo.Age.Int64 = 0</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;get data, id: &quot;, dbw.UserInfo.Id, &quot; name: &quot;, dbw.UserInfo.Name.String, &quot; age: &quot;, int(dbw.UserInfo.Age.Int64))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = rows.Err()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习中的一些记录，随心记</title>
      <link href="/2018/09/24/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%EF%BC%8C%E9%9A%8F%E5%BF%83%E8%AE%B0/"/>
      <url>/2018/09/24/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%EF%BC%8C%E9%9A%8F%E5%BF%83%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Python扩展包大全：https-www-lfd-uci-edu-gohlke-pythonlibs"><a href="#Python扩展包大全：https-www-lfd-uci-edu-gohlke-pythonlibs" class="headerlink" title="Python扩展包大全：https://www.lfd.uci.edu/~gohlke/pythonlibs"></a><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs" target="_blank" rel="noopener">Python扩展包大全</a>：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs</a></h2><h2 id="docker删除none标签镜像："><a href="#docker删除none标签镜像：" class="headerlink" title="docker删除none标签镜像："></a>docker删除none标签镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images|grep none|awk <span class="string">'&#123;print $3 &#125;'</span>|xargs docker rmi</span><br></pre></td></tr></table></figure><h2 id="go使用reflect-TypeOf-x-判断x的数据类型：import-“reflect”"><a href="#go使用reflect-TypeOf-x-判断x的数据类型：import-“reflect”" class="headerlink" title="go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”"></a>go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”</h2><h2 id="查看当前目录下各文件夹占用空间，深度1："><a href="#查看当前目录下各文件夹占用空间，深度1：" class="headerlink" title="查看当前目录下各文件夹占用空间，深度1："></a>查看当前目录下各文件夹占用空间，深度1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -h --max-depth=1</span><br></pre></td></tr></table></figure><h2 id="Golang-在windows下编译Linux下可执行文件-一定要用cmd-，在程序根目录下设置编译环境："><a href="#Golang-在windows下编译Linux下可执行文件-一定要用cmd-，在程序根目录下设置编译环境：" class="headerlink" title="Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境："></a>Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux  </span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="Linux后台运行并且不生成nohup-out文件："><a href="#Linux后台运行并且不生成nohup-out文件：" class="headerlink" title="Linux后台运行并且不生成nohup.out文件："></a>Linux后台运行并且不生成nohup.out文件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./程序名 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="抓包命令-："><a href="#抓包命令-：" class="headerlink" title="抓包命令 ："></a>抓包命令 ：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -iany host 127.0.0.1 -XNnn </span><br><span class="line">tcpdump -iany port 80 -XNnn</span><br></pre></td></tr></table></figure><h2 id="php容器中添加pdo-mysql扩展模块"><a href="#php容器中添加pdo-mysql扩展模块" class="headerlink" title="php容器中添加pdo_mysql扩展模块"></a>php容器中添加pdo_mysql扩展模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-php-ext-install pdo_mysql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随心笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 烂笔头 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Python3的Flask教程中文版</title>
      <link href="/2018/09/24/%E5%9F%BA%E4%BA%8EPython3%E7%9A%84Flask%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2018/09/24/%E5%9F%BA%E4%BA%8EPython3%E7%9A%84Flask%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AHello%2C%20World!.md" target="_blank" rel="noopener">第一章：Hello, World!</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF.md" target="_blank" rel="noopener">第二章：模板</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AWeb%E8%A1%A8%E5%8D%95.md" target="_blank" rel="noopener">第三章：Web表单</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93.md" target="_blank" rel="noopener">第四章：数据库</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.md" target="_blank" rel="noopener">第五章：用户登录</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E5%92%8C%E5%A4%B4%E5%83%8F.md" target="_blank" rel="noopener">第六章：个人主页和头像</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">第七章：错误处理</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E7%B2%89%E4%B8%9D.md" target="_blank" rel="noopener">第八章：粉丝</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E5%88%86%E9%A1%B5.md" target="_blank" rel="noopener">第九章：分页</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%82%AE%E4%BB%B6%E6%94%AF%E6%8C%81.md" target="_blank" rel="noopener">第十章：邮件支持</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BE%8E%E5%8C%96.md" target="_blank" rel="noopener">第十一章：美化</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.md" target="_blank" rel="noopener">第十二章：日期和时间</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96.md" target="_blank" rel="noopener">第十三章：国际化和本地化</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9AAjax.md" target="_blank" rel="noopener">第十四章：Ajax</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BC%98%E5%8C%96%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener">第十五章：优化应用结构</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2.md" target="_blank" rel="noopener">第十六章：全文搜索</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9ALinux%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十七章：Linux上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%EF%BC%9AHeroku%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十八章：Heroku上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9ADocker%E5%AE%B9%E5%99%A8%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十九章：Docker容器上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8A%A0%E7%82%B9JavaScript%E9%AD%94%E6%B3%95.md" target="_blank" rel="noopener">第二十章：加点JavaScript魔法</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E9%80%9A%E7%9F%A5.md" target="_blank" rel="noopener">第二十一章：用户通知</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A.md" target="_blank" rel="noopener">第二十二章：后台作业</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88API%EF%BC%89.md" target="_blank" rel="noopener">第二十三章：应用程序编程接口（API）</a></p>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang中json、map、struct互相转换</title>
      <link href="/2018/09/24/Golang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/09/24/Golang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF8000" size="5" face="楷体">json转struct</font><br>使用json.Unmarshal时，结构体的每一项必须是导出项（import field）。也就是说结构体的key对应的首字母必须大写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;encoding/json&quot;</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">   Name string `json:&quot;name_tile&quot;`</span><br><span class="line">   Age int `json:&quot;age_size&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func JsonToStructDemo() &#123;</span><br><span class="line">   jsonStr := `</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;name_tile&quot;: &quot;liuXX&quot;,</span><br><span class="line">      &quot;age_size&quot;: 12</span><br><span class="line">   &#125;</span><br><span class="line">   `</span><br><span class="line">   var people People</span><br><span class="line">   json.Unmarshal([]byte(jsonStr), &amp;people)</span><br><span class="line">   fmt.Println(people)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   JsonToStructDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">struct转json</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;testing&quot;</span><br><span class="line">   &quot;encoding/json&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">   Name string `json:&quot;name_tILE&quot;`</span><br><span class="line">   Age int `json:&quot;AGE_SIZE&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func TestStructToJson(t *testing.T) &#123;</span><br><span class="line">   p := People&#123;</span><br><span class="line">      Name: &quot;Liu xx&quot;,</span><br><span class="line">      Age: 18,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t.Logf(&quot;Person 结构体打印结果:%v&quot;, p)</span><br><span class="line"></span><br><span class="line">   //Person 结构体转换为对应的 Json</span><br><span class="line">   jsonBytes, err := json.Marshal(p)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">json转map</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func TestJsonToMap(t *testing.T) &#123;</span><br><span class="line">   jsonStr := `</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Liu XX&quot;,</span><br><span class="line">      &quot;age&quot;: 18</span><br><span class="line">   &#125;</span><br><span class="line">   `</span><br><span class="line">   var mapResult map[string]interface&#123;&#125;</span><br><span class="line">   //使用 json.Unmarshal(data []byte, v interface&#123;&#125;)进行转换,返回 error 信息</span><br><span class="line">   if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Log(mapResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">map转json</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func TestMapToJson(t *testing.T) &#123;</span><br><span class="line">   mapInstance := make(map[string]interface&#123;&#125;)</span><br><span class="line">   mapInstance[&quot;Name&quot;] = &quot;Liu xx&quot;</span><br><span class="line">   mapInstance[&quot;Age&quot;] = 18</span><br><span class="line">   mapInstance[&quot;Address&quot;] = &quot;广东 深圳&quot;</span><br><span class="line"></span><br><span class="line">   jsonStr, err := json.Marshal(mapInstance)</span><br><span class="line"></span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t.Logf(&quot;TestMapToJson 得到 json 字符串内容:%s&quot;, jsonStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">map转struct</font><br>map转换struct要用第三方库提供的方法：$ go get github.com/goinggo/mapstructure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestMapToStruct(t *testing.T) &#123;</span><br><span class="line">   mapInstance := make(map[string]interface&#123;&#125;)</span><br><span class="line">   mapInstance[&quot;Name&quot;] = &quot;liang637210&quot;</span><br><span class="line">   mapInstance[&quot;Age&quot;] = 28</span><br><span class="line"></span><br><span class="line">   var people People</span><br><span class="line">   //将 map 转换为指定的结构体</span><br><span class="line">   if err := mapstructure.Decode(mapInstance, &amp;people); err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">struct转map</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">   Id int `json:&quot;id&quot;`</span><br><span class="line">   Username string `json:&quot;username&quot;`</span><br><span class="line">   Password string `json:&quot;password&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StructToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123;</span><br><span class="line">   t := reflect.TypeOf(obj)</span><br><span class="line">   v := reflect.ValueOf(obj)</span><br><span class="line"></span><br><span class="line">   var data = make(map[string]interface&#123;&#125;)</span><br><span class="line">   for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">      data[t.Field(i).Name] = v.Field(i).Interface()</span><br><span class="line">&#125;</span><br><span class="line">   return data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestStructToMap(t *testing.T) &#123;</span><br><span class="line">   user := User&#123;5, &quot;zhangsan&quot;, &quot;password&quot;&#125;</span><br><span class="line">   data := StructToMap(user)</span><br><span class="line">   t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
