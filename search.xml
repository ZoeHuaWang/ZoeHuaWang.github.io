<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go的cron定时任务用法]]></title>
    <url>%2F2018%2F12%2F27%2FGo%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[安装第三方库robfig/cron：1go get -u github.com/robfig/cron 应用： 每秒钟执行一次1234567891011121314151617181920package mainimport ( &quot;log&quot; &quot;github.com/robfig/cron&quot;)func main() &#123; i := 0 c := cron.New() //秒 分 时 日 月 周 spec := &quot;*/1 * * * * *&quot; c.AddFunc(spec, func() &#123; i++ log.Println(&quot;execute per second&quot;, i) &#125;) c.Start() select &#123;&#125;&#125; 其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go数学运算随机数]]></title>
    <url>%2F2018%2F11%2F15%2FGo%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[总是要有使用随机数的情况。这就需要使用math包。12345678910package mainimport( &quot;fmt&quot; &quot;math/rand&quot;)func main()&#123; fmt.Println(&quot;My random number is&quot;, rand.Intn(200))&#125; 运行上面的代码就会发现每次返回的随机数是不变的。因为运行环境是没有发生变化的。为了每次得到不同的随机数，就需要一个随机数种子。 时间是不停的在发生变化的，利用time.Now().UnixNano()获得一个带纳秒的时间戳，形成一个新源。然后随机数就可以有想要的效果了。123456789101112package mainimport( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main()&#123; rand.Seed(time.Now().UnixNano()) fmt.Println(&quot;My random number is&quot;, rand.Intn(200))&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang的格式化输出]]></title>
    <url>%2F2018%2F10%2F11%2FGolang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BAfmt%2F</url>
    <content type="text"><![CDATA[123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name:&quot;zhangsan&quot;&#125; 1234567普通占位符占位符 说明 举例 输出%v 相应值的默认格式。 Printf(&quot;%v&quot;, people) &#123;zhangsan&#125;，%+v 打印结构体时，会添加字段名 Printf(&quot;%+v&quot;, people) &#123;Name:zhangsan&#125;%#v 相应值的Go语法表示 Printf(&quot;#v&quot;, people) main.Human&#123;Name:&quot;zhangsan&quot;&#125;%T 相应值的类型的Go语法表示 Printf(&quot;%T&quot;, people) main.Human%% 字面上的百分号，并非值的占位符 Printf(&quot;%%&quot;) % 123布尔占位符占位符 说明 举例 输出%t true 或 false。 Printf(&quot;%t&quot;, true) true 12345678910整数占位符占位符 说明 举例 输出%b 二进制表示 Printf(&quot;%b&quot;, 5) 101%c 相应Unicode码点所表示的字符 Printf(&quot;%c&quot;, 0x4E2D) 中%d 十进制表示 Printf(&quot;%d&quot;, 0x12) 18%o 八进制表示 Printf(&quot;%d&quot;, 10) 12%q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(&quot;%q&quot;, 0x4E2D) &apos;中&apos;%x 十六进制表示，字母形式为小写 a-f Printf(&quot;%x&quot;, 13) d%X 十六进制表示，字母形式为大写 A-F Printf(&quot;%x&quot;, 13) D%U Unicode格式：U+1234，等同于 &quot;U+%04X&quot; Printf(&quot;%U&quot;, 0x4E2D) U+4E2D 123456789浮点数和复数的组成部分（实部和虚部）占位符 说明 举例 输出%b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 &apos;b&apos; 转换格式一致。例如 -123456p-78%e 科学计数法，例如 -1234.456e+78 Printf(&quot;%e&quot;, 10.2) 1.020000e+01%E 科学计数法，例如 -1234.456E+78 Printf(&quot;%e&quot;, 10.2) 1.020000E+01%f 有小数点而无指数，例如 123.456 Printf(&quot;%f&quot;, 10.2) 10.200000%g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20) 10.2%G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i) 123456字符串与字节切片占位符 说明 举例 输出%s 输出字符串表示（string类型或[]byte) Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;)) Go语言%q 双引号围绕的字符串，由Go语法安全地转义 Printf(&quot;%q&quot;, &quot;Go语言&quot;) &quot;Go语言&quot;%x 十六进制，小写字母，每字节两个字符 Printf(&quot;%x&quot;, &quot;golang&quot;) 676f6c616e67%X 十六进制，大写字母，每字节两个字符 Printf(&quot;%X&quot;, &quot;golang&quot;) 676F6C616E67 123指针占位符 说明 举例 输出%p 十六进制表示，前缀 0x Printf(&quot;%p&quot;, &amp;people) 0x4f57f0 12345678910111213其它标记占位符 说明 举例 输出+ 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(&quot;%+q&quot;, &quot;中文&quot;) &quot;\u4e2d\u6587&quot;- 在右侧而非左侧填充空格（左对齐该区域）# 备用格式：为八进制添加前导 0（%#o） Printf(&quot;%#U&quot;, &apos;中&apos;) U+4E2D 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。&apos; &apos; (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。%e 和 %f 的默认精度为6对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux awk命令详解]]></title>
    <url>%2F2018%2F09%2F25%2Fawk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[默认每行按空格或TAB分割：awk &#39;{print $1,$4}&#39; log.txt -F,指定分割字符：awk -F : &#39;{print $1,$4}&#39; log.txt 指定多个分割字符,先用:分割,然后再用,分割：awk -F &#39;[:,]&#39; &#39;{print $1,$4}&#39; log.txt -v,指定变量：awk -v a=1 -v b=s &#39;{print $1,$1+a,$1b}&#39; log.txt -f,调用awk脚本：awk -f script.awk log.txt //,纯字符匹配：awk &#39;/dockerroot/&#39; /etc/passwd !//,纯字符不匹配：awk &#39;!/dockerroot/&#39; /etc/passwd /|/,匹配a1或a2：awk &#39;!/a1|a2/&#39; /etc/passwd ~//,字段值匹配：awk &#39;$1~/root/&#39; /etc/passwd !~//,字段值不匹配：awk -F : &#39;$1!~/root/&#39; /etc/passwd IF语句,必须用在{}中，且比较内容用()扩起来if…else…：awk -F: &#39;{if($1~/root/) {print $1} else {print $2}}&#39; /etc/passwd 逻辑运算符：&amp;&amp;?|| 条件表达式：== != &gt; &gt;= while语句：awk -F: &#39;BEGIN{i=1} {while(i&lt;8) print $i,i++}&#39; /etc/passwd NF、NR：NF代表每行字段数，NR代表行号]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.3编译安装go1.8.1]]></title>
    <url>%2F2018%2F09%2F25%2FCentOS7-3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1-8-1%2F</url>
    <content type="text"><![CDATA[go1.8.1下载地址https://golang.org/dl/，这里下载go1.8.1.src.tar.gz和go1.4.3.src.tar.gz，下来以后算下md5哈希和官网比对下，以免被加盐； go1.4以上版本安装的时候需先安装下1.4；要么会报类似下面的错：1234##### Building Go bootstrap tool.cmd/distERROR: Cannot find /root/go1.4/bin/go.Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4. 开始安装：12345yum install gcc glibc-devel -ytar -C /root/ -xvf go1.4.3.src.tar.gzmv /root/go/ /root/go1.4cd /root/go1.4/src./all.bash 约１分钟左右安装完成，设置下环境变量并重新加载123echo &quot;export PATH=$PATH:/root/go1.4/bin&quot; &gt;&gt; /etc/profileecho &quot;export GOROOT=/root/go1.4&quot; &gt;&gt; /etc/profilesource /etc/profile 使用go version查看版本已经是go1.4.3了 开始安装go1.8.1123tar -C /usr/local/ -xvf go1.8.1.src.tar.gzcd /usr/local/go/src/./all.bash 安装完成以后，清除掉之前添加的/etc/profile里面的环境变量信息，增加如下配置123export PATH=$PATH:/usr/local/go/binexport GOROOT=/usr/local/goexport GOPATH=/usr/local/go-projects 重新加载配置source /etc/profile 查看版本go version,已经是1.8.1了 创建go的hello world程序：1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 保存为hello.go直接运行 go run hello.go返回hello，world！ 至此，go1.8.1安装完毕！或者直接使用编译好的包：go1.10.1.linux-amd64.tar.gz下载go$wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz$tar -xvf go1.10.1.linux-amd64.tar.gz设置环境变量$vim /etc/profile添加12345export GOPATH=/data/work/gopathexport GOBIN=$GOPATH/binexport GOROOT=/data/work/goexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin:$GOBINsource /etc/profile $GOPATH工作目录结构，约定有三个子目录（需要自行创建）：src ——存放源代码文件pkg——存放编译后的文件bin ——存放编译后的可执行文件测试环境:创建目录 /data/work/gopath/src123$mkdir helloworld$cd helloworld$vim main.go 输入:1234567package main import &quot;fmt&quot; func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Linux上安装GO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openresty笔记]]></title>
    <url>%2F2018%2F09%2F25%2Fopenresty%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[–启动命令：/usr/local/openresty/bin/openresty–停止命令：/usr/local/openresty/bin/openresty -s stop–重启命令：/usr/local/openresty/bin/openresty -s reload–检验nginx配置是否正确：/usr/local/openresty/bin/openresty -t 开发时可以把server里面的location中的 lua_code_cache 设置为 off; 线上不要，代价太大。 ngx.say() 直接返回请求结果ngx.req.read_body() 获取post body值ngx.req.get_post_args() 获取post参数ngx.req.get_uri_args() 获取url中参数 一个lua的表函数要有类似C++类函数的this指针（self）用冒号(:)调用函数时，会默认传一个值(self)作为第一个参数;用点(.)调用函数时，则没有； 连。接。调。用。redis redis模块引用：在nginx主配置文件的http部分添加如下配置 ，其中”;;”表示默认搜索路径。lua_package_path “/usr/local/openresty/lualib/resty/?.lua;;”; #lua 模块lua_package_cpath “yourpath/?.so;;”; #c模块 local redis = require(“resty.redis”) #导入 resty.redis 模块local red = redis:new() #实例化 redis 对象red:set_timeout(1000) #设置超时（毫秒）local ok, err = red:connect(“127.0.0.1”, 6379) #连接到服务器local ok, err = red:auth(“yourpasswd”) #验证（如果要验证）local ok, err = red:set_keepalive(1000, 100) #将连接添加到连接池中local ok, err = red:set(“dog”, “an animal”) #redis的set操作local res, err = red:get(“dog”) #redis的get操作red:close() #关闭连接,如果使用连接池就不需要关闭 启用连接池需要开启 lua_code_cache on测试连接池时，线程数需要小于set_keepalive中的第二个参数（即连接数）]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go操作mysql建表问题的解决办法]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[table.sql 文件内容如下123456DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;, `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; go 代码如下：1234567891011121314151617181920212223func createTable() (err error) &#123; host := &quot;127.0.0.1&quot; port := &quot;3306&quot; user := &quot;root&quot; pass := &quot;admin&quot; name := &quot;test&quot; sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;); if err != nil &#123; return &#125; sqlTable := string(sqlBytes); fmt.Println(sqlTable) db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;) if err != nil &#123; return &#125; defer db.Close() _, err = db.Exec(sqlTable) if err != nil &#123; return &#125; return nil&#125; 执行，出错：12Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1 刚开始是以为 sql 语句有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql语句的问题。查找资料才知道原因 默认是不能在同时执行两条 sql 语句的 解决办法：1.将 多条 sql 语句拆开，每个语句单独执行 db.Exec()2.查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下 (增加了 &amp;multiStatements=true 参数)db, err := sql.Open(“mysql”, user+”:”+pass+”@tcp(“+host+”:”+port+”)/“+name+”?charset=utf8&amp;multiStatements=true”)]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang操作mysql使用案例]]></title>
    <url>%2F2018%2F09%2F25%2FGolang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)type DbWorker struct &#123; Dsn string Db *sql.DB UserInfo userTB&#125;type userTB struct &#123; Id int Name sql.NullString Age sql.NullInt64&#125;func main() &#123; var err error dbw := DbWorker&#123; Dsn: &quot;root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4&quot;, &#125; dbw.Db, err = sql.Open(&quot;mysql&quot;, dbw.Dsn) if err != nil &#123; panic(err) return &#125; defer dbw.Db.Close() dbw.insertData() dbw.queryData()&#125;func (dbw *DbWorker) insertData() &#123; stmt, _ := dbw.Db.Prepare(`INSERT INTO user (name, age) VALUES (?, ?)`) defer stmt.Close() ret, err := stmt.Exec(&quot;xys&quot;, 23) if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; if LastInsertId, err := ret.LastInsertId(); nil == err &#123; fmt.Println(&quot;LastInsertId:&quot;, LastInsertId) &#125; if RowsAffected, err := ret.RowsAffected(); nil == err &#123; fmt.Println(&quot;RowsAffected:&quot;, RowsAffected) &#125;&#125;func (dbw *DbWorker) QueryDataPre() &#123; dbw.UserInfo = userTB&#123;&#125;&#125;func (dbw *DbWorker) queryData() &#123; stmt, _ := dbw.Db.Prepare(`SELECT * From user where age &gt;= ? AND age &lt; ?`) defer stmt.Close() dbw.QueryDataPre() rows, err := stmt.Query(20, 30) defer rows.Close() if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; for rows.Next() &#123; rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age) if err != nil &#123; fmt.Printf(err.Error()) continue &#125; if !dbw.UserInfo.Name.Valid &#123; dbw.UserInfo.Name.String = &quot;&quot; &#125; if !dbw.UserInfo.Age.Valid &#123; dbw.UserInfo.Age.Int64 = 0 &#125; fmt.Println(&quot;get data, id: &quot;, dbw.UserInfo.Id, &quot; name: &quot;, dbw.UserInfo.Name.String, &quot; age: &quot;, int(dbw.UserInfo.Age.Int64)) &#125; err = rows.Err() if err != nil &#123; fmt.Printf(err.Error()) &#125;&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习中的一些记录，随心记]]></title>
    <url>%2F2018%2F09%2F24%2F%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python扩展包大全：https://www.lfd.uci.edu/~gohlke/pythonlibsdocker删除none标签镜像：1$ docker images|grep none|awk '&#123;print $3 &#125;'|xargs docker rmi go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”查看当前目录下各文件夹占用空间，深度1：1$ du -h --max-depth=1 Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境：1234SET CGO_ENABLED=0SET GOOS=linux SET GOARCH=amd64go build Linux后台运行并且不生成nohup.out文件：1nohup ./程序名 &gt;/dev/null 2&gt;&amp;1 &amp; 抓包命令 ：12tcpdump -iany host 127.0.0.1 -XNnn tcpdump -iany port 80 -XNnn]]></content>
      <categories>
        <category>随心笔记</category>
      </categories>
      <tags>
        <tag>烂笔头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python3的Flask教程中文版]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%9F%BA%E4%BA%8E%20Python%203%20%E7%9A%84%20Flask%20%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[第一章：Hello, World!第二章：模板第三章：Web表单第四章：数据库第五章：用户登录第六章：个人主页和头像第七章：错误处理第八章：粉丝第九章：分页第十章：邮件支持第十一章：美化第十二章：日期和时间第十三章：国际化和本地化第十四章：Ajax第十五章：优化应用结构第十六章：全文搜索第十七章：Linux上的部署第十八章：Heroku上的部署第十九章：Docker容器上的部署第二十章：加点JavaScript魔法第二十一章：用户通知第二十二章：后台作业第二十三章：应用程序编程接口（API）]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Flask教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中json、map、struct互相转换]]></title>
    <url>%2F2018%2F09%2F24%2FGolang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[json转struct使用json.Unmarshal时，结构体的每一项必须是导出项（import field）。也就是说结构体的key对应的首字母必须大写。123456789101112131415161718192021222324252627package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type People struct &#123; Name string `json:&quot;name_tile&quot;` Age int `json:&quot;age_size&quot;`&#125;func JsonToStructDemo() &#123; jsonStr := ` &#123; &quot;name_tile&quot;: &quot;liuXX&quot;, &quot;age_size&quot;: 12 &#125; ` var people People json.Unmarshal([]byte(jsonStr), &amp;people) fmt.Println(people)&#125;func main() &#123; JsonToStructDemo()&#125; struct转json12345678910111213141516171819202122232425262728package testimport ( &quot;testing&quot; &quot;encoding/json&quot;)type People struct &#123; Name string `json:&quot;name_tILE&quot;` Age int `json:&quot;AGE_SIZE&quot;`&#125;func TestStructToJson(t *testing.T) &#123; p := People&#123; Name: &quot;Liu xx&quot;, Age: 18, &#125; t.Logf(&quot;Person 结构体打印结果:%v&quot;, p) //Person 结构体转换为对应的 Json jsonBytes, err := json.Marshal(p) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))&#125; json转map1234567891011121314func TestJsonToMap(t *testing.T) &#123; jsonStr := ` &#123; &quot;name&quot;: &quot;Liu XX&quot;, &quot;age&quot;: 18 &#125; ` var mapResult map[string]interface&#123;&#125; //使用 json.Unmarshal(data []byte, v interface&#123;&#125;)进行转换,返回 error 信息 if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil &#123; t.Fatal(err) &#125; t.Log(mapResult)&#125; map转json1234567891011121314func TestMapToJson(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;Liu xx&quot; mapInstance[&quot;Age&quot;] = 18 mapInstance[&quot;Address&quot;] = &quot;广东 深圳&quot; jsonStr, err := json.Marshal(mapInstance) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;TestMapToJson 得到 json 字符串内容:%s&quot;, jsonStr)&#125; map转structmap转换struct要用第三方库提供的方法：$ go get github.com/goinggo/mapstructure123456789101112func TestMapToStruct(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;liang637210&quot; mapInstance[&quot;Age&quot;] = 28 var people People //将 map 转换为指定的结构体 if err := mapstructure.Decode(mapInstance, &amp;people); err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, people)&#125; struct转map12345678910111213141516171819202122type User struct &#123; Id int `json:&quot;id&quot;` Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;`&#125;func StructToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123; t := reflect.TypeOf(obj) v := reflect.ValueOf(obj) var data = make(map[string]interface&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; data[t.Field(i).Name] = v.Field(i).Interface()&#125; return data&#125;func TestStructToMap(t *testing.T) &#123; user := User&#123;5, &quot;zhangsan&quot;, &quot;password&quot;&#125; data := StructToMap(user) t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
</search>
