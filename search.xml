<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql增量备份]]></title>
    <url>%2F2019%2F12%2F31%2Fmysql%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[前提：必须开启binlog， 若没开启log_bin，则修改mysql配置文件my.cnf，添加以下配置，重启mysql使配置生效 全量备份脚本： 123456789101112131415161718192021222324252627282930313233343536#!/bin/bashbackuppath="/home/ccodrunner/mysqlforbak"backupdate=`date +%Y%m%d`logpath="/home/ccodrunner/mysqlforbak/log"logfile="/home/ccodrunner/mysqlforbak/log/backup-0.log"username="ucds"password="ucds"if [ ! -d $backuppath ];then mkdir -p $backuppathfiif [ ! -d $logpath ];then mkdir -p $logpathfiecho "" &gt;&gt; $logfileecho "-------------------" &gt;&gt; $logfileecho "BACKUP DATE:"$(date +"%Y-%m-%d %H:%M:%S") &gt;&gt; $logfileecho "-------------------" &gt;&gt; $logfile#备份全库/usr/bin/mysqldump -u$username -p$password --all-databases --flush-logs --single-transaction --quick --delete-master-logs &gt; $backuppath/alldb_$&#123;backupdate&#125;.sqlif [[ $? == 0 ]];then cd $backuppath tar -zcvf alldb_$&#123;backupdate&#125;.sql.tar.gz alldb_$&#123;backupdate&#125;.sql echo "Backup Successful !" &gt;&gt; $logfileelse echo "Database Backup Fail !" &gt;&gt; $logfilefiecho "Backup Process Done !" &gt;&gt; $logfile#删除7天前的备份find $backuppath -mtime +7 -name "*.sql.tar.gz" -exec rm -rf &#123;&#125; \;rm -rf $backuppath/alldb_$&#123;backupdate&#125;.sqlecho "Delete Process Done" &gt;&gt; $logfile 增量备份脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bashbackuppath="/home/ccodrunner/mysqlforbak/BinLogBack"mysqlpath="/var/lib/mysql"logpath="/home/ccodrunner/mysqlforbak/log"logfile="/home/ccodrunner/mysqlforbak/log/backup-1.log"binFile="/var/lib/mysql/mysql-bin.index"username="ucds"password="ucds"if [ ! -d $backuppath ];then mkdir -p $backuppathfiif [ ! -d $logpath ];then mkdir -p $logpathfiecho "" &gt;&gt; $logfileecho "-------------------" &gt;&gt; $logfileecho "BACKUP DATE:"$(date +"%Y-%m-%d %H:%M:%S") &gt;&gt; $logfileecho "-------------------" &gt;&gt; $logfile/usr/bin/mysqladmin -u$username -p$password flush-logscounter=`wc -l $binFile | awk '&#123;print $1&#125;'`nextNum=0for file in `cat $binFile`do base_file=`basename $file` #basename 用于截取mysql-bin.00000*文件名，去掉./mysql-bin.000005前面的./ nextNum=`expr $nextNum + 1` if [ $nextNum -eq $counter ] then echo "$base_file skip !" &gt;&gt; $logfile else dest=$backuppath/$base_file if (test -e $dest) then echo "$base_file exist !" &gt;&gt; $logfile else cp $mysqlpath/$base_file $backuppath echo "$base_file copying" &gt;&gt; $logfile fi fidoneecho [PartBack] `date +"%Y%m%d %H:%M:%S"` $nextNum Backup successful ! &gt;&gt; $logfile 定时任务: 1201 03 * * 0 /bin/bash 全量备份脚本路径 &gt;/dev/null 2&gt;&amp;101 03 * * 1-6 /bin/bash 增量备份脚本路径 &gt;/dev/null 2&gt;&amp;1 恢复： 1、先恢复完整库： mysql -u root -p school &lt; /opt/school.sql 2、恢复 增量备份： msyqlbinlog –no-defaults msyql-bin.0000002 | msyql -u root -p]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维笔记]]></title>
    <url>%2F2019%2F11%2F20%2F%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041find /home/* -mmin +120 -exec rm -rf &#123;&#125; \;#home目录下所有文件更新时间距现在时刻大于120分钟的文件删除(-mtime -3 表示3天以内)awk '&#123; $3="";$4=""; print $0 &#125;' a.txt#awk打印除某些列之外的所有列tar -zcf XXX.tar.gz XXX --remove-files #打包成tar包之后删除原文件jar -uvf XXX.jar 包内文件 包外文件#替换jar包内文件(包内要和包外的路径对应一致，不然会说没有这个文件)sort file1 file2 | uniq -u #去除两个文件重复部分ln –s 源文件 目标文件 #软链接ls --full-time filename #查看文件生成全部时间zcat XXX.tar.gz | grep --binary-files=text "Read time out"#不解压筛选查看tar.gz包(或zgrep --binary-files=text "Read time out" X.tar.gz)tcpdump -iany host 127.0.0.1 -XNnn 、 tcpdump -iany port 80 -XNnn #抓包命令time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time())) #python时间格式mysql -h 127.0.0.1 -u用户名 -p密码 --default-character-set=utf8 -e "sql语句" &gt; tt.txt#mysql查询结果以utf8编码导出到txt文件HOME=/home/oracle mysql -e "sql语句" 或 mysql --defaults-file=/home/oracle#/home/oracle/下存放连接mysql的用户名密码文件.my.cnf，然后以安全方式连接mysqlif [ -n "$var" ];then #判断$var变量是否有值(有)|xargs -i -t #-t 表示先打印命令，然后再执行；-i 一般是一行一行赋值给 &#123;&#125;#xargs 用作替换工具，读取输入数据重新格式化后输出1、sync2、echo 3 &gt; /proc/sys/vm/drop_caches 3、echo 0 &gt; /proc/sys/vm/drop_caches#Linux下清除文件系统缓存#查看哪个安装包包含该库：yum provides 库名 12345678910111213select version(); #查看mysql版本stop slave;set global sql_slave_skip_counter=1;start slave; #从库不同步处理，第二句表示跳过一步错误,后面的数字可变use table;flush tables with read lock; #备份锁表use table;unlock tables; #解锁 select a.id,a.column,b.id,b.column from a left join b on a.id = b.id#关联查询set global expire_logs_days = 10;flush logs; #设置自动删除binlog文件的天数PURGE MASTER LOGS BEFORE DATE_SUB(CURRENT_DATE, INTERVAL 10 DAY); #删除10天前的binlogr日志 1234567891011121314151617181920212223242526lsnrctl start #打开oracle监听sqlplus #进入oraclesqlplus / as sysdba #以dba身份连接到sql控制台shutdown immediate #停止服务startup #启动服务#oracle查看表空间：SELECT a.tablespace_name &quot;表空间名&quot;,total &quot;表空间大小&quot;,free &quot;表空间剩余大小&quot;,(total - free) &quot;表空间使用大小&quot;,total / (1024 * 1024 * 1024) &quot;表空间大小(G)&quot;,free / (1024 * 1024 * 1024) &quot;表空间剩余大小(G)&quot;,(total - free) / (1024 * 1024 * 1024) &quot;表空间使用大小(G)&quot;,round((total - free) / total, 4) * 100 &quot;使用率 %&quot;FROM (SELECT tablespace_name, SUM(bytes) freeFROM dba_free_spaceGROUP BY tablespace_name) a,(SELECT tablespace_name, SUM(bytes) totalFROM dba_data_filesGROUP BY tablespace_name) bWHERE a.tablespace_name = b.tablespace_name#oracle表空间扩容：select * from dba_data_files where tablespace_name = &apos;SD_TABLE_SD_0211300003&apos;;alter tablespace SD_TABLE_SD_0211300003 add datafile &apos;/home/oracle/oracle10g/db_files/SD/SD_TABLE_sd_02113000033.dbf&apos; size 10240M autoextend on; 12345docker inspect CONTAINER_NAME #查看容器所有信息docker container port CONTAINER_NAME #查看容器端口映射信息docker logs CONTAINER_NAME #查看启动日志在docker run的时候加上--privileged=true参数，然后在最后面加上/usr/sbin/init。内部取得root权限(centos7)容器启动自动执行~/.bashrc 1234567891011#python3常用进制转换：hex(16) # 10进制转16进制oct(8) # 10进制转8进制bin(8) # 10进制转2进制int('10') # 字符串转换成10进制整数int('10',16) # 字符串转换成16进制整数int('0x10',16) # 字符串转换成16进制整数int('10',8) # 字符串转换成8进制整数int('010',8) # 字符串转换成8进制整数int('10',2) # 字符串转换成2进制整数]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask使用MySql数据库]]></title>
    <url>%2F2019%2F06%2F14%2FFlask%E4%BD%BF%E7%94%A8MySql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[环境说明1Centos7 + python3.6 + mysql5.7 1.安装Flask-SQLAlchemy，pymyql驱动12pip install flask-sqlalchemypip intall pymysql 2.使用Flask-SQLAlchemyFlask-SQLAlchemy数据库URL常用的数据库引擎： 数据库引擎 URL MySql mysql+pymysql://username:password@host/database Postgres postgresql://username:password@host/database app.py编辑 1234567891011121314151617181920#导入模块from flask_sqlalchemy import SQLAlchemyimport pymysql#创建flask对象app = Flask(__name__)#配置flask配置对象中键：SQLALCHEMY_DATABASE_URIapp.config['SQLALCHEMY_DATABASE_URI'] = "mysql+pymysql://username:password@hostname/database"#配置flask配置对象中键：SQLALCHEMY_COMMIT_TEARDOWN,设置为True,应用会自动在每次请求结束后提交数据库中变动app.config['SQLALCHEMY_COMMIT_TEARDOWN'] = Tureapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Trueapp.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True#获取SQLAlchemy实例对象，接下来就可以使用对象调用数据db = SQLAlchemy(app) 3.sqlalchemy列常见参数 选择项 说明 autoincrement True 是否自增 primary_key True 是否是主键 index TRUE 是否是索引 unique True 是否是唯一 nullable True 是否允许字段为空 default 默认值 4.字段类型 类型名称 python类型 描述 Integer int 常规整型，通常为32位 SmallInteger int 短整型，通常为16位 BigInteger int或long 精度不受限整型 Float float 浮点型 Numeric decimal 定点数 String str 可变长度字符串 Text str 可变长度字符串，适合大量文本 Unicode unicode 可变长度Unicode字符串 Boolean bool 布尔值 Date datetime.date 日期类型 Time datetime.time 时间类型 DateTime datetime.datetime 日期时间类型 Interval datetime.timedate 时间间隔 Enum str 字符列表 PickleType 任意Python对象 自动Pickle序列化 LargeBinary str 二进制 5.使用sqlalchemy1234567891011121314151617181920212223242526272829303132333435from app import db#创建模型对象class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) #repr()方法显示一个可读字符串 def __repr__(self): return '&lt;User %r&gt;' % self.username# 1.创建表db.create_all()# 2.删除表db.drop_all() # 3.增加记录admin = User(username='admin', email='admin@example.com')guest = User(username='guest', email='guest@example.com')db.session.add(admin)db.session.add(guest)db.session.commit()# 4.查询记录,注意查询返回对象，如果查询不到返回NoneUser.query.all() #查询所有User.query.filter_by(username='admin').first() #条件查询User.query.order_by(User.username).all() #排序查询User.query.limit(1).all() #查询1条User.query.get(4) #精确查找(参数为主键)# 5.删除user = User.query.get(4)db.session.delete(user)db.session.commit()]]></content>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中yield的用法详解]]></title>
    <url>%2F2019%2F06%2F05%2Fpython%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序： 123456789def foo(): print("starting...") while True: res = yield 4 print("res:",res)g = foo()print(next(g))print("*"*20)print(next(g)) 就这么简单的几行代码就让你明白什么是yield，代码的输出这个： 12345starting...4********************res: None4 下面直接解释代码运行顺序，相当于代码单步调试： 1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象) 2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环 3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果， 4.程序执行print(““20)，输出20个* 5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None, 6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4. 再看一个这个生成器的send函数的例子，这个例子就把上面那个例子的最后一行换掉了: 123456789def foo(): print("starting...") while True: res = yield 4 print("res:",res)g = foo()print(next(g))print("*"*20)print(g.send(7)) 输出结果： 12345starting...4********************res: 74 程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量。 第一次使用生成器需要send(None)或者next()唤醒next() 只唤醒yiedl不传递值send() 唤醒yiedl并传递值]]></content>
      <tags>
        <tag>Python、Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企点开放平台接入之消息加解密指南]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[出于安全考虑，第三方开发者服务器在与企点服务器互相传递数据时必须对消息进行加解密（某些事件可能回复时也需要先进行加密）。而通过主调的方式调用接口时则不需要进行加密。 当第三方为集成商模式时后台可能会接收到两种类型的消息：1、用户没有开发能力或自己不处理，企点推送给用户的消息由第三方代收。此时，消息XML体中，ToUserName（即接收者）为企点的原始ID（可通过《接口说明》中的获取授权方信息接口来获得）。2、企点服务器发送给集成商自身的事件推送（如取消授权通知，Ticket推送等）。此时，消息XML体中没有ToUserName字段，而是AppId字段，即企点服务的AppId。这种系统事件推送通知（现在包括推送component_verify_ticket协议和推送取消授权通知），收到后也需进行解密并且只需直接返回字符串”success”就可以。 而当第三方为开发者模式时，则没有上面的第2种消息。具体消息加解密的做法是：1、先对接收到的消息进行验证签名，用于验证消息体的正确性，验签指引请查看本页末相关文档——服务器配置指引2、验签通过之后再对消息进行解密处理，消息解密流程图：3、提供加解密Demo供参考：http://api.qidian.qq.com/wiki/images/file/demo.zip 注意事项：1、EncodingAESKey为消息加解密密钥，长度固定为43个字符，从a-z,A-Z,0-9共62个字符中选取。2、出于安全考虑，开放平台网站提供了修改EncodingAESKey的功能（在EncodingAESKey可能泄漏时进行修改），所以建议企点账号保存当前的和上一次的EncodingAESKey，若当前EncodingAESKey解密失败，则尝试用上一次的EncodingAESKey的解密。回包时，用哪个解密成功，则用此哪个加密对应的回包。 相关文档：服务器配置接入指引]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>企点API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企点开放平台接入服务器配置指南]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1、搭建自己的服务器开发者需要建立一个http或者https服务的Demo，包含了验证签名的逻辑，如图：参数提取php代码示例:123456789101112131415161718192021222324252627282930&lt;?php/* Created by PhpStorm.* User: Administrator* Date: 2016/6/28* Time: 17:28*/ if(isset($_GET[&apos;signature&apos;]))&#123; $signature=$_GET[&apos;signature&apos;]; &#125; if(isset($_GET[&apos;timestamp&apos;]))&#123; $timestamp=$_GET[&apos;timestamp&apos;]; &#125; if(isset($_GET[&apos;nonce&apos;]))&#123; $nonce=$_GET[&apos;nonce&apos;]; &#125; if(isset($_GET[&apos;echostr&apos;]))&#123; $echostr=$_GET[&apos;echostr&apos;]; &#125; $token=&quot;token1&quot;; $params=array($token,$timestamp,$nonce); sort($params,SORT_STRING); $str = implode($params); $sign = sha1($str); if($sign!=$signature)&#123; return 0; &#125; echo $echostr; 2、验证服务准备就绪之后开启服务，回到账户中心点击“检测并保存”按钮，如下图，企点后台会向该服务器发送http的get请求，若提示”验证失败”相关, 请认真检查代码或网络链接等。 注意：服务器地址(URL)校验通过后会存储在企点api后台，后续的事件推送也是请求该地址；区分这2种请求的方法是看http中的request method，服务器签名校验中是GET，事件推送中是POST。事件推送参见消息加解密接入指引 相关文档：消息加解密接入指引]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>企点API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企点开放平台接入指南]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BC%81%E7%82%B9%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[使用方式目前使用企点开发平台有两种方式：主调和回调1、主调：是指开发者通过AppId和AppSecret直接调用企点的开放接口，AppId和AppSecret需要注册获得。2、回调：在有些业务场景中需要用到企点的消息推送能力，企点通过http请求开发者服务器将需要的信息推送给对方服务器，并且对方收到消息后需要做出事件回复响应，这种情况称为企点的回调。此过程中的消息传递都要经过加密处理，消息加解密接入指引请查看本页末相关文档。 注册配置要使用企点开放平台首先要注册成为开发者。1、打开企点官网首页，使用管理员QQ登录2、进入企业管理的开发配置填写企点开发信息和服务器配置信息，服务器配置指引请查看本页末相关文档，配置好后如图：3、配置完成后可自行测试接口调用建议使用Postman进行接口在线调试，Postman下载链接：https://www.getpostman.com/调用说明：1)、开发配置中的AppId和AppSecret可用于换取接口调用凭证access_token，通过access_token来调用其他Api开放接口。2)、我们post数据目前大部分都是以json数据post方法调用。所以json数据要在body中使用raw格式推送。不能使用form-data,或者x-www-urlencoded, 一定要注意，否则调用接口可能失败。 相关文档：服务器配置接入指引消息加解密接入指引获取access_token]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>企点API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企点自定义传参]]></title>
    <url>%2F2019%2F03%2F27%2F%E4%BC%81%E7%82%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[首先，我们先来看下预想的效果图：从这个图我们可以知道，用户进入会话前的身份信息和从进入会话的产品页都会被收录在会话窗口右侧自定义的页面上，这个客户库页面可以通过创建聊天窗口右侧自定义页面接口来创建，那么这些信息又是如何收集到的呢？接下来可以通过下面的流程图理解下1、当带有自定义参数的wpa被C用户点击并且打开会话窗口的时候，企点srv会获取到这些自定义的参数并且把他们推送到商户开发者的后台服务器上；2、商户开发人员利用收集到的参数信息与相应的客户id关联起来并在本地做好对应的存储关系；3、B侧收到消息打开会话窗口，而当B想要知道是什么样的客户进来了，就可以直接点击窗口右侧的自定义客户库页面；4、客户库页面被点击的瞬间企点srv会自动跳转到这个页面并在URL中携带返回给开发者需要的信息（fromUser、toUser、custId等）；5、商户开发人员拿到对应的客户id与之前的本地存储匹配就可以获取到自定义的参数；6、有了自定义的参数就可以去自己的客户系统里面拿取相应的客户信息并且展示在这个客户库页面上为了更加有效的清楚整个流程，我们做了一个实际的例子：先通过自定义传参接口给wpa添加自定义参数，目前支持的自定义参数为：qidian_ex1、qidian_ex2、qidian_ex3、qidian_ex4、qidian_ex5，值的长度不超过64字节。通过API接口或账户中心创建的接待组件，然后在部署接待组件的页面上设置自定义参数传参示例：此页面定义了两个自定的参数：qidian_ex1和qidian_ex2。当点击下面的wpa组件的时候会，开发者服务器会收到相应的event事件推送，并且会把这两个参数携带上推过去事件推送如下面的图：接着B侧打开通过创建聊天窗口右侧自定义页面接口创建的页面TEST，企点会自动跳转到这个TEST页面并在URL参数中返回给商户开发者需要的信息（fromUser、toUser、custId等），toUser指的是客户的openid；如果是网页会话就是个visitorid（如果客户不更换电脑系统和浏览器每个人的visitorid是不会变的），通过toUser就可以与之前的event事件关联起来得到相应的自定义参数。示例图如下：这样用户从哪个商品页进来和携带了哪些客户信息就可以通过这两个参数去匹配出相应的信息进而展示在右侧自定义页面上，因此就能实现追踪用户来源等信息的能力自定义传参实现的需求场景有很多，典型常用的就是在客户登录的情况下与客服会话，客服需要知道是谁进来了，此时在会话窗口右侧自定义页面直接展示客户信息。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>企点API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能客服机器人与企点的对接]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%8E%E4%BC%81%E7%82%B9%E7%9A%84%E5%AF%B9%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[本文将讲解机器人与企点是如何结合应用的，先来看QQ的通路；对于C侧用户来说面对的是一个机器人，因此用户需要指定一个工号来作为机器人的角色统一回复。QQ用户、机器人和客服人员这三者之间的关系网如图：下面来逐步解析整个消息的走向：1、当C侧用户通过wpa触点进入后，开始上行消息到机器人工号2、上行消息后，企点svr会把消息推送给第三方后台服务，抄送示例图：3、第三方拿到消息之后，把消息给到机器人处理是否需要转人工&nbsp;&nbsp;&nbsp;&nbsp;A、不需要转接人工:&nbsp;&nbsp;&nbsp;&nbsp;1、直接通过FAQ问答系统匹配相应的回复给第三方处理&nbsp;&nbsp;&nbsp;&nbsp;2、第三方得到机器人的回复后调用企点的消息发送接口，通过机器人工号将消息下行到C侧用户，如图：&nbsp;&nbsp;&nbsp;&nbsp;B、如果需要转人工，那就利用企点的QQ会话转接接口把会话转到人工客服，由人工来接待这是目前的整体流程，但是还有如下可以优化的细节，我们一起来看下。一、在寻求人工客服的时候，C触及到人工客服B的方式有个特殊的情况：就是并不是通过wpa触点进来，而是直接通过号码搜索或好友聊天的方式跳过机器人直接联系到客服B了，那么这样的话机器人就起不到应有的作用了。虽然这种特殊情况发生的概率极低，但在未来我们也会对相关逻辑进行优化。二、人工接待分配逻辑，在机器人工号转人工客服的时候，QQ会话转接接口的toOpenid参数是一个客服工号，并不能指定接待组；因此这个分配逻辑只能是用户自己来决定，在不久的未来我们也会发布相应的功能接口（截止到2019年4月1日转接接口都还不能做到转接给接待组）三、消息过滤逻辑，因为企点这边所有的消息推送都会推送给第三方后台，为了避免消息错乱重复等问题，第三方开发人员还需要自己制定一个消息过滤逻辑四、为了所有环境下进来的消息都能通过机器人来管控把关，必须把所有相关的wpa接待组件接待人都统一设置为机器人工号独立接待，而且在客服分配溢出及防漏客机制下也要设置机器人工号为唯一紧急接待人 WebIm通路与QQ通路情况类似，可以用同一套方法，但webim通路在人工接待分配逻辑这点不同的是可以指定转接到接待组；还有一个就是因为是临时访客会话，所以不存在C不通过wpa组件直接触达B的情况发生。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>企点API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker之Dockerfile]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%AD%A6%E4%B9%A0Docker%E4%B9%8BDockerfile%2F</url>
    <content type="text"><![CDATA[组成部分12345| 部分 | 命令 || 基础镜像信息 | FROM || 维护者信息 | MAINTAINER || 镜像操作指令 | RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等 || 容器启动时执行指令 | CMD、ENTRYPOINT |各命令详解FROM指定哪种镜像作为新镜像的基础镜像，如：1FROM ubuntu:14.04MAINTAINER指明该镜像的作者和其电子邮件，如：1MAINTAINER Zoe.wang &quot;xxxxxxx@qq.com&quot;RUN在新镜像内部执行的命令，比如安装一些软件、配置一些基础环境，可使用\来换行，如：12RUN echo &apos;hello docker!&apos; \ &gt; /usr/local/file.txt也可以使用exec格式RUN [“executable”, “param1”, “param2”]的命令，如：1RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]要注意的是，executable是命令，后面的param是参数COPY将主机的文件复制到镜像内，如果目的位置不存在，Docker会自动创建所有需要的目录结构，但是它只是单纯的复制，并不会去做文件提取和解压工作。如：1COPY application.yml /etc/springboot/hello-service/src/resources注意：需要复制的目录一定要放在Dockerfile文件的同级目录下ADD将主机的文件复制到镜像中，跟COPY一样，限制条件和使用方式都一样，如：1ADD application.yml /etc/springboot/hello-service/src/resourcesEXPOSE暴露镜像的端口供主机做映射，启动镜像时，使用-P参数来讲镜像端口与宿主机的随机端口做映射。使用方式（可指定多个）：123EXPOSE 8080 EXPOSE 8081...WORKDIR在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录。如1234WORKDIR /usr/localWORKDIR webserviceRUN echo &apos;hello docker&apos; &gt; text.txt...最终会在/usr/local/webservice/目录下生成text.txt文件ONBUILD当一个包含ONBUILD命令的镜像被用作其他镜像的基础镜像时(比如用户的镜像需要从某为准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本)，该命令就会执行。如创建镜像image-A1234FROM ubuntu...ONBUILD ADD . /var/www...然后创建镜像image-B，指定image-A为基础镜像，如12FROM image-A...然后在构建image-B的时候，日志上显示如下:1234Step 0 : FROM image-A# Execting 1 build triggersStep onbuild-0 : ADD . /var/www...USER指定该镜像以什么样的用户去执行，如：1USER mongoVOLUME用来向基于镜像创建的容器添加卷。比如你可以将mongodb镜像中存储数据的data文件指定为主机的某个文件。(容器内部建议不要存储任何数据)如：1VOLUME /data/db /data/configdb注意:VOLUME 主机目录 容器目录CMD容器启动时需要执行的命令，如：1CMD /bin/bash同样可以使用exec语法，如1CMD [&quot;/bin/bash&quot;]当有多个CMD的时候，只有最后一个生效。ENTRYPOINT作用和用法和CMD一模一样CMD和ENTRYPOINT的区别敲黑板！！！非常重要一定要注意！一定要注意！一定要注意CMD的命令会被 docker run 的命令覆盖而ENTRYPOINT不会CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖，如：123...ENTRYPOINT [&quot;echo&quot;,&quot;hello&quot;,&quot;i am&quot;]CMD [&quot;docker&quot;]之后启动构建之后的容器使用docker run -ti image 输出“hello i am docker” 使用docker run -ti image world 输出“hello i am world”]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新稳定万能vip视频解析接口]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E4%B8%87%E8%83%BDvip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[全网解析 支持站点奇艺视频 腾讯 优酷 土豆 芒果 乐视 搜狐 PPTV 华数TV 风行 咪咕 哔哩哔哩 ACfun 暴风 CCTV CNTV 范特西 9i广场舞 搜狐自媒体 M1905视频 看看视频 27盘 虎牙直播 全民直播 战旗直播 人人视频 爆米花 今日头条 天翼视频 糖豆视频 龙珠视频 快手视频一直播 新浪视频 360小视频 熊猫TV 斗鱼TV 花椒直播 网易公开课 音悦台 秒拍网 美拍网 爱拍 凤凰视频 梨视频 微录客 人民微视频 17173视频 优米视频 m3u8 mp4视频 微博视频 YY视频 私有云资源 https://cdn.yangju.vip/k/?url=后面加上播放的地址即可1234567891011https://cdn.yangju.vip/k/?url=https://jx.lache.me/cc/?url=https://api.653520.top/vip/?url=https://jx.ab33.top/vip/?url=https://vip.mpos.ren/v/?url=https://jx.000180.top/jx/?url=https://jx.km58.top/jx/?url=https://api.smq1.com/?url=https://jx.hezeshi.net/ce/jlexi.php?url=https://www.kkflv.com/?url= //Btjson智能解析https://jx.618g.com/?url= //618G解析 永久性，重要的是够稳定！而且CDN加速！！解析接口支持:URL模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go的cron定时任务用法]]></title>
    <url>%2F2018%2F12%2F27%2FGo%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[安装第三方库robfig/cron：1go get -u github.com/robfig/cron 应用： 每秒钟执行一次1234567891011121314151617181920package mainimport ( &quot;log&quot; &quot;github.com/robfig/cron&quot;)func main() &#123; i := 0 c := cron.New() //秒 分 时 日 月 周 spec := &quot;*/1 * * * * *&quot; c.AddFunc(spec, func() &#123; i++ log.Println(&quot;execute per second&quot;, i) &#125;) c.Start() select &#123;&#125;&#125; 其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go数学运算随机数]]></title>
    <url>%2F2018%2F11%2F15%2FGo%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[总是要有使用随机数的情况。这就需要使用math包。12345678910package mainimport( &quot;fmt&quot; &quot;math/rand&quot;)func main()&#123; fmt.Println(&quot;My random number is&quot;, rand.Intn(200))&#125; 运行上面的代码就会发现每次返回的随机数是不变的。因为运行环境是没有发生变化的。为了每次得到不同的随机数，就需要一个随机数种子。 时间是不停的在发生变化的，利用time.Now().UnixNano()获得一个带纳秒的时间戳，形成一个新源。然后随机数就可以有想要的效果了。123456789101112package mainimport( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main()&#123; rand.Seed(time.Now().UnixNano()) fmt.Println(&quot;My random number is&quot;, rand.Intn(200))&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang的格式化输出]]></title>
    <url>%2F2018%2F10%2F11%2FGolang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[123456# 定义示例类型和变量type Human struct &#123; Name string&#125;var people = Human&#123;Name:&quot;zhangsan&quot;&#125; 1234567普通占位符占位符 说明 举例 输出%v 相应值的默认格式。 Printf(&quot;%v&quot;, people) &#123;zhangsan&#125;，%+v 打印结构体时，会添加字段名 Printf(&quot;%+v&quot;, people) &#123;Name:zhangsan&#125;%#v 相应值的Go语法表示 Printf(&quot;#v&quot;, people) main.Human&#123;Name:&quot;zhangsan&quot;&#125;%T 相应值的类型的Go语法表示 Printf(&quot;%T&quot;, people) main.Human%% 字面上的百分号，并非值的占位符 Printf(&quot;%%&quot;) % 123布尔占位符占位符 说明 举例 输出%t true 或 false。 Printf(&quot;%t&quot;, true) true 12345678910整数占位符占位符 说明 举例 输出%b 二进制表示 Printf(&quot;%b&quot;, 5) 101%c 相应Unicode码点所表示的字符 Printf(&quot;%c&quot;, 0x4E2D) 中%d 十进制表示 Printf(&quot;%d&quot;, 0x12) 18%o 八进制表示 Printf(&quot;%d&quot;, 10) 12%q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(&quot;%q&quot;, 0x4E2D) &apos;中&apos;%x 十六进制表示，字母形式为小写 a-f Printf(&quot;%x&quot;, 13) d%X 十六进制表示，字母形式为大写 A-F Printf(&quot;%x&quot;, 13) D%U Unicode格式：U+1234，等同于 &quot;U+%04X&quot; Printf(&quot;%U&quot;, 0x4E2D) U+4E2D 123456789浮点数和复数的组成部分（实部和虚部）占位符 说明 举例 输出%b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 &apos;b&apos; 转换格式一致。例如 -123456p-78%e 科学计数法，例如 -1234.456e+78 Printf(&quot;%e&quot;, 10.2) 1.020000e+01%E 科学计数法，例如 -1234.456E+78 Printf(&quot;%e&quot;, 10.2) 1.020000E+01%f 有小数点而无指数，例如 123.456 Printf(&quot;%f&quot;, 10.2) 10.200000%g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20) 10.2%G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i) 123456字符串与字节切片占位符 说明 举例 输出%s 输出字符串表示（string类型或[]byte) Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;)) Go语言%q 双引号围绕的字符串，由Go语法安全地转义 Printf(&quot;%q&quot;, &quot;Go语言&quot;) &quot;Go语言&quot;%x 十六进制，小写字母，每字节两个字符 Printf(&quot;%x&quot;, &quot;golang&quot;) 676f6c616e67%X 十六进制，大写字母，每字节两个字符 Printf(&quot;%X&quot;, &quot;golang&quot;) 676F6C616E67 123指针占位符 说明 举例 输出%p 十六进制表示，前缀 0x Printf(&quot;%p&quot;, &amp;people) 0x4f57f0 12345678910111213其它标记占位符 说明 举例 输出+ 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(&quot;%+q&quot;, &quot;中文&quot;) &quot;\u4e2d\u6587&quot;- 在右侧而非左侧填充空格（左对齐该区域）# 备用格式：为八进制添加前导 0（%#o） Printf(&quot;%#U&quot;, &apos;中&apos;) U+4E2D 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。&apos; &apos; (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。%e 和 %f 的默认精度为6对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.3编译安装go1.8.1]]></title>
    <url>%2F2018%2F09%2F25%2FCentOS7.3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1.8.1%2F</url>
    <content type="text"><![CDATA[go1.8.1下载地址https://golang.org/dl/，这里下载go1.8.1.src.tar.gz和go1.4.3.src.tar.gz，下来以后算下md5哈希和官网比对下，以免被加盐； go1.4以上版本安装的时候需先安装下1.4；要么会报类似下面的错：1234##### Building Go bootstrap tool.cmd/distERROR: Cannot find /root/go1.4/bin/go.Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4. 开始安装：12345yum install gcc glibc-devel -ytar -C /root/ -xvf go1.4.3.src.tar.gzmv /root/go/ /root/go1.4cd /root/go1.4/src./all.bash 约１分钟左右安装完成，设置下环境变量并重新加载123echo &quot;export PATH=$PATH:/root/go1.4/bin&quot; &gt;&gt; /etc/profileecho &quot;export GOROOT=/root/go1.4&quot; &gt;&gt; /etc/profilesource /etc/profile 使用go version查看版本已经是go1.4.3了 开始安装go1.8.1123tar -C /usr/local/ -xvf go1.8.1.src.tar.gzcd /usr/local/go/src/./all.bash 安装完成以后，清除掉之前添加的/etc/profile里面的环境变量信息，增加如下配置123export PATH=$PATH:/usr/local/go/binexport GOROOT=/usr/local/goexport GOPATH=/usr/local/go-projects 重新加载配置source /etc/profile 查看版本go version,已经是1.8.1了 创建go的hello world程序：1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 保存为hello.go直接运行 go run hello.go返回hello，world！ 至此，go1.8.1安装完毕！或者直接使用编译好的包：go1.10.1.linux-amd64.tar.gz下载go$wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz$tar -xvf go1.10.1.linux-amd64.tar.gz设置环境变量$vim /etc/profile添加12345export GOPATH=/data/work/gopathexport GOBIN=$GOPATH/binexport GOROOT=/data/work/goexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin:$GOBINsource /etc/profile $GOPATH工作目录结构，约定有三个子目录（需要自行创建）：src ——存放源代码文件pkg——存放编译后的文件bin ——存放编译后的可执行文件测试环境:创建目录 /data/work/gopath/src123$mkdir helloworld$cd helloworld$vim main.go 输入:1234567package main import &quot;fmt&quot; func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Linux上安装GO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openresty笔记]]></title>
    <url>%2F2018%2F09%2F25%2Fopenresty%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[–启动命令：/usr/local/openresty/bin/openresty–停止命令：/usr/local/openresty/bin/openresty -s stop–重启命令：/usr/local/openresty/bin/openresty -s reload–检验nginx配置是否正确：/usr/local/openresty/bin/openresty -t 开发时可以把server里面的location中的 lua_code_cache 设置为 off; 线上不要，代价太大。 ngx.say() 直接返回请求结果ngx.req.read_body() 获取post body值ngx.req.get_post_args() 获取post参数ngx.req.get_uri_args() 获取url中参数 一个lua的表函数要有类似C++类函数的this指针（self）用冒号(:)调用函数时，会默认传一个值(self)作为第一个参数;用点(.)调用函数时，则没有； 连。接。调。用。redis redis模块引用：在nginx主配置文件的http部分添加如下配置 ，其中”;;”表示默认搜索路径。lua_package_path “/usr/local/openresty/lualib/resty/?.lua;;”; #lua 模块lua_package_cpath “yourpath/?.so;;”; #c模块 local redis = require(“resty.redis”) #导入 resty.redis 模块local red = redis:new() #实例化 redis 对象red:set_timeout(1000) #设置超时（毫秒）local ok, err = red:connect(“127.0.0.1”, 6379) #连接到服务器local ok, err = red:auth(“yourpasswd”) #验证（如果要验证）local ok, err = red:set_keepalive(1000, 100) #将连接添加到连接池中local ok, err = red:set(“dog”, “an animal”) #redis的set操作local res, err = red:get(“dog”) #redis的get操作red:close() #关闭连接,如果使用连接池就不需要关闭 启用连接池需要开启 lua_code_cache on测试连接池时，线程数需要小于set_keepalive中的第二个参数（即连接数）]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux awk命令详解]]></title>
    <url>%2F2018%2F09%2F25%2Fawk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[默认每行按空格或TAB分割：awk &#39;{print $1,$4}&#39; log.txt -F,指定分割字符：awk -F : &#39;{print $1,$4}&#39; log.txt 指定多个分割字符,先用:分割,然后再用,分割：awk -F &#39;[:,]&#39; &#39;{print $1,$4}&#39; log.txt -v,指定变量：awk -v a=1 -v b=s &#39;{print $1,$1+a,$1b}&#39; log.txt -f,调用awk脚本：awk -f script.awk log.txt //,纯字符匹配：awk &#39;/dockerroot/&#39; /etc/passwd !//,纯字符不匹配：awk &#39;!/dockerroot/&#39; /etc/passwd /|/,匹配a1或a2：awk &#39;!/a1|a2/&#39; /etc/passwd ~//,字段值匹配：awk &#39;$1~/root/&#39; /etc/passwd !~//,字段值不匹配：awk -F : &#39;$1!~/root/&#39; /etc/passwd IF语句,必须用在{}中，且比较内容用()扩起来if…else…：awk -F: &#39;{if($1~/root/) {print $1} else {print $2}}&#39; /etc/passwd 逻辑运算符：&amp;&amp;?|| 条件表达式：== != &gt; &gt;= while语句：awk -F: &#39;BEGIN{i=1} {while(i&lt;8) print $i,i++}&#39; /etc/passwd NF、NR：NF代表每行字段数，NR代表行号]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go操作mysql建表问题的解决办法]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[table.sql 文件内容如下123456DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;, `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; go 代码如下：1234567891011121314151617181920212223func createTable() (err error) &#123; host := &quot;127.0.0.1&quot; port := &quot;3306&quot; user := &quot;root&quot; pass := &quot;admin&quot; name := &quot;test&quot; sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;); if err != nil &#123; return &#125; sqlTable := string(sqlBytes); fmt.Println(sqlTable) db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;) if err != nil &#123; return &#125; defer db.Close() _, err = db.Exec(sqlTable) if err != nil &#123; return &#125; return nil&#125; 执行，出错：12Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1 刚开始是以为 sql 语句有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql语句的问题。查找资料才知道原因 默认是不能在同时执行两条 sql 语句的 解决办法：1.将 多条 sql 语句拆开，每个语句单独执行 db.Exec()2.查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下 (增加了 &amp;multiStatements=true 参数)db, err := sql.Open(“mysql”, user+”:”+pass+”@tcp(“+host+”:”+port+”)/“+name+”?charset=utf8&amp;multiStatements=true”)]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang操作mysql使用案例]]></title>
    <url>%2F2018%2F09%2F25%2FGolang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)type DbWorker struct &#123; Dsn string Db *sql.DB UserInfo userTB&#125;type userTB struct &#123; Id int Name sql.NullString Age sql.NullInt64&#125;func main() &#123; var err error dbw := DbWorker&#123; Dsn: &quot;root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4&quot;, &#125; dbw.Db, err = sql.Open(&quot;mysql&quot;, dbw.Dsn) if err != nil &#123; panic(err) return &#125; defer dbw.Db.Close() dbw.insertData() dbw.queryData()&#125;func (dbw *DbWorker) insertData() &#123; stmt, _ := dbw.Db.Prepare(`INSERT INTO user (name, age) VALUES (?, ?)`) defer stmt.Close() ret, err := stmt.Exec(&quot;xys&quot;, 23) if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; if LastInsertId, err := ret.LastInsertId(); nil == err &#123; fmt.Println(&quot;LastInsertId:&quot;, LastInsertId) &#125; if RowsAffected, err := ret.RowsAffected(); nil == err &#123; fmt.Println(&quot;RowsAffected:&quot;, RowsAffected) &#125;&#125;func (dbw *DbWorker) QueryDataPre() &#123; dbw.UserInfo = userTB&#123;&#125;&#125;func (dbw *DbWorker) queryData() &#123; stmt, _ := dbw.Db.Prepare(`SELECT * From user where age &gt;= ? AND age &lt; ?`) defer stmt.Close() dbw.QueryDataPre() rows, err := stmt.Query(20, 30) defer rows.Close() if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; for rows.Next() &#123; rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age) if err != nil &#123; fmt.Printf(err.Error()) continue &#125; if !dbw.UserInfo.Name.Valid &#123; dbw.UserInfo.Name.String = &quot;&quot; &#125; if !dbw.UserInfo.Age.Valid &#123; dbw.UserInfo.Age.Int64 = 0 &#125; fmt.Println(&quot;get data, id: &quot;, dbw.UserInfo.Id, &quot; name: &quot;, dbw.UserInfo.Name.String, &quot; age: &quot;, int(dbw.UserInfo.Age.Int64)) &#125; err = rows.Err() if err != nil &#123; fmt.Printf(err.Error()) &#125;&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python3的Flask教程中文版]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%9F%BA%E4%BA%8EPython3%E7%9A%84Flask%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[第一章：Hello, World!第二章：模板第三章：Web表单第四章：数据库第五章：用户登录第六章：个人主页和头像第七章：错误处理第八章：粉丝第九章：分页第十章：邮件支持第十一章：美化第十二章：日期和时间第十三章：国际化和本地化第十四章：Ajax第十五章：优化应用结构第十六章：全文搜索第十七章：Linux上的部署第十八章：Heroku上的部署第十九章：Docker容器上的部署第二十章：加点JavaScript魔法第二十一章：用户通知第二十二章：后台作业第二十三章：应用程序编程接口（API）]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Flask教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习中的一些记录，随心记]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%EF%BC%8C%E9%9A%8F%E5%BF%83%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python扩展包大全：https://www.lfd.uci.edu/~gohlke/pythonlibsdocker删除none标签镜像：1$ docker images|grep none|awk '&#123;print $3 &#125;'|xargs docker rmi go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”查看当前目录下各文件夹占用空间，深度1：1$ du -h --max-depth=1 Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境：1234SET CGO_ENABLED=0SET GOOS=linux SET GOARCH=amd64go build Linux后台运行并且不生成nohup.out文件：1nohup ./程序名 &gt;/dev/null 2&gt;&amp;1 &amp; 抓包命令 ：12tcpdump -iany host 127.0.0.1 -XNnn tcpdump -iany port 80 -XNnn php容器中添加pdo_mysql扩展模块1docker-php-ext-install pdo_mysql]]></content>
      <categories>
        <category>随心笔记</category>
      </categories>
      <tags>
        <tag>烂笔头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中json、map、struct互相转换]]></title>
    <url>%2F2018%2F09%2F24%2FGolang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[json转struct使用json.Unmarshal时，结构体的每一项必须是导出项（import field）。也就是说结构体的key对应的首字母必须大写。123456789101112131415161718192021222324252627package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type People struct &#123; Name string `json:&quot;name_tile&quot;` Age int `json:&quot;age_size&quot;`&#125;func JsonToStructDemo() &#123; jsonStr := ` &#123; &quot;name_tile&quot;: &quot;liuXX&quot;, &quot;age_size&quot;: 12 &#125; ` var people People json.Unmarshal([]byte(jsonStr), &amp;people) fmt.Println(people)&#125;func main() &#123; JsonToStructDemo()&#125; struct转json12345678910111213141516171819202122232425262728package testimport ( &quot;testing&quot; &quot;encoding/json&quot;)type People struct &#123; Name string `json:&quot;name_tILE&quot;` Age int `json:&quot;AGE_SIZE&quot;`&#125;func TestStructToJson(t *testing.T) &#123; p := People&#123; Name: &quot;Liu xx&quot;, Age: 18, &#125; t.Logf(&quot;Person 结构体打印结果:%v&quot;, p) //Person 结构体转换为对应的 Json jsonBytes, err := json.Marshal(p) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))&#125; json转map1234567891011121314func TestJsonToMap(t *testing.T) &#123; jsonStr := ` &#123; &quot;name&quot;: &quot;Liu XX&quot;, &quot;age&quot;: 18 &#125; ` var mapResult map[string]interface&#123;&#125; //使用 json.Unmarshal(data []byte, v interface&#123;&#125;)进行转换,返回 error 信息 if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil &#123; t.Fatal(err) &#125; t.Log(mapResult)&#125; map转json1234567891011121314func TestMapToJson(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;Liu xx&quot; mapInstance[&quot;Age&quot;] = 18 mapInstance[&quot;Address&quot;] = &quot;广东 深圳&quot; jsonStr, err := json.Marshal(mapInstance) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;TestMapToJson 得到 json 字符串内容:%s&quot;, jsonStr)&#125; map转structmap转换struct要用第三方库提供的方法：$ go get github.com/goinggo/mapstructure123456789101112func TestMapToStruct(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;liang637210&quot; mapInstance[&quot;Age&quot;] = 28 var people People //将 map 转换为指定的结构体 if err := mapstructure.Decode(mapInstance, &amp;people); err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, people)&#125; struct转map12345678910111213141516171819202122type User struct &#123; Id int `json:&quot;id&quot;` Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;`&#125;func StructToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123; t := reflect.TypeOf(obj) v := reflect.ValueOf(obj) var data = make(map[string]interface&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; data[t.Field(i).Name] = v.Field(i).Interface()&#125; return data&#125;func TestStructToMap(t *testing.T) &#123; user := User&#123;5, &quot;zhangsan&quot;, &quot;password&quot;&#125; data := StructToMap(user) t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
</search>
