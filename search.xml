<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>客服机器人对接QQ和WebIM</title>
      <link href="/2019/03/25/%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%B9%E6%8E%A5QQ%E5%92%8CWebIM/"/>
      <url>/2019/03/25/%E5%AE%A2%E6%9C%8D%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%B9%E6%8E%A5QQ%E5%92%8CWebIM/</url>
      
        <content type="html"><![CDATA[<font color="red" size="4" face="微软雅黑">QQ和WebIM两种通路的对接方式是一样的，只是两种通路下的客户id方式不一样，因此下面说的对接三步对两种方式来说都能适用</font><br><font color="#9400D3" size="8" face="楷体">整体框架示意图：</font><br><img src="/img/客服机器人对接QQ和WebIM.png"><br><font color="#9400D3" size="8" face="楷体">实现原理：</font><br>实现逻辑其实很简单，首先第三方客户得和企点开放平台对接成功，具体如何对接可以参考企点开放平台官网指导。其次得有自己的一个机器人，这个就是自己决定用哪家了；一切就绪之后可以来看下逻辑步骤。<br><font color="#FF8000" size="5" face="楷体">Step一：</font>指定一个企点工号作为客服机器人，当有客户进线上行消息时候，企点会把消息抄送给第三方<br><img src="/img/消息抄送.png"><br><font color="#FF8000" size="5" face="楷体">Step二：</font>第三方在收到由企点推送过来的客户消息后，利用自己的机器人来判断内容该做出什么回复<br><font color="#FF8000" size="5" face="楷体">Step三：</font>第三方把需要按照机器人回复的内容通过企点消息发送接口来把回复内容发送给客户，客户收到消息流程完毕<br><img src="/img/发送消息.png"><br><font color="red" size="4" face="微软雅黑">如果转接人工客服：在机器人识别出客户需要转人工的时候，可以调用企点的转接接口把客户转接的对应的人工客服上。</font>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企点API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Docker之Dockerfile</title>
      <link href="/2019/02/26/%E5%AD%A6%E4%B9%A0Docker%E4%B9%8BDockerfile/"/>
      <url>/2019/02/26/%E5%AD%A6%E4%B9%A0Docker%E4%B9%8BDockerfile/</url>
      
        <content type="html"><![CDATA[<font color="black" size="6" face="楷体">组成部分</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 部分| 命令|</span><br><span class="line">| 基础镜像信息| FROM|</span><br><span class="line">| 维护者信息| MAINTAINER|</span><br><span class="line">| 镜像操作指令| RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME等|</span><br><span class="line">| 容器启动时执行指令| CMD、ENTRYPOINT|</span><br></pre></td></tr></table></figure><br><br><font color="black" size="6" face="楷体">各命令详解</font><br><font color="#9400D3" size="4" face="楷体">FROM</font><br>指定哪种镜像作为新镜像的基础镜像，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">MAINTAINER</font><br>指明该镜像的作者和其电子邮件，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Zoe.wang &quot;xxxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">RUN</font><br>在新镜像内部执行的命令，比如安装一些软件、配置一些基础环境，可使用\来换行，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &apos;hello docker!&apos; \</span><br><span class="line">    &gt; /usr/local/file.txt</span><br></pre></td></tr></table></figure><br><br>也可以使用exec格式<font color="red">RUN [“executable”, “param1”, “param2”]</font>的命令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</span><br></pre></td></tr></table></figure><br><br>要注意的是，executable是命令，后面的param是参数<br><font color="#9400D3" size="4" face="楷体">COPY</font><br>将主机的文件复制到镜像内，如果目的位置不存在，Docker会自动创建所有需要的目录结构，但是它只是单纯的复制，并不会去做文件提取和解压工作。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY application.yml /etc/springboot/hello-service/src/resources</span><br></pre></td></tr></table></figure><br><br><font color="#FF8000" size="4">注意：需要复制的目录一定要放在Dockerfile文件的同级目录下</font><br><font color="#9400D3" size="4" face="楷体">ADD</font><br>将主机的文件复制到镜像中，跟COPY一样，限制条件和使用方式都一样，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD application.yml /etc/springboot/hello-service/src/resources</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">EXPOSE</font><br>暴露镜像的端口供主机做映射，启动镜像时，使用-P参数来讲镜像端口与宿主机的随机端口做映射。使用方式（可指定多个）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080 </span><br><span class="line">EXPOSE 8081</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">WORKDIR</font><br>在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /usr/local</span><br><span class="line">WORKDIR webservice</span><br><span class="line">RUN echo &apos;hello docker&apos; &gt; text.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>最终会在<font color="red">/usr/local/webservice/</font>目录下生成text.txt文件<br><font color="#9400D3" size="4" face="楷体">ONBUILD</font><br>当一个包含ONBUILD命令的镜像被用作其他镜像的基础镜像时(比如用户的镜像需要从某为准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本)，该命令就会执行。<br>如创建镜像image-A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">...</span><br><span class="line">ONBUILD ADD . /var/www</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>然后创建镜像image-B，指定image-A为基础镜像，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>然后在构建image-B的时候，日志上显示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 0 : FROM image-A</span><br><span class="line"># Execting 1 build triggers</span><br><span class="line">Step onbuild-0 : ADD . /var/www</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">USER</font><br>指定该镜像以什么样的用户去执行，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mongo</span><br></pre></td></tr></table></figure><br><br><font color="#9400D3" size="4" face="楷体">VOLUME</font><br>用来向基于镜像创建的容器添加卷。比如你可以将mongodb镜像中存储数据的data文件指定为主机的某个文件。(容器内部建议不要存储任何数据)<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data/db /data/configdb</span><br></pre></td></tr></table></figure><br><br>注意:<font color="red">VOLUME 主机目录 容器目录</font><br><font color="#9400D3" size="4" face="楷体">CMD</font><br>容器启动时需要执行的命令，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><br><br>同样可以使用exec语法，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure><br><br>当有多个CMD的时候，只有最后一个生效。<br><font color="#9400D3" size="4" face="楷体">ENTRYPOINT</font><br>作用和用法和CMD一模一样<br><font color="gray" size="4" face="楷体">CMD和ENTRYPOINT的区别</font><br>敲黑板！！！非常重要<br>一定要注意！<br><br>一定要注意！<br><br>一定要注意<br>CMD的命令会被 docker run 的命令覆盖而ENTRYPOINT不会<br>CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;hello&quot;,&quot;i am&quot;]</span><br><span class="line">CMD [&quot;docker&quot;]</span><br></pre></td></tr></table></figure><br><br>之后启动构建之后的容器<br><br>使用<font color="red">docker run -ti image</font><p>输出<font color="red">“hello i am docker”</font></p><p>使用<font color="red">docker run -ti image world</font></p><p>输出<font color="red">“hello i am world”</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最新稳定万能vip视频解析接口</title>
      <link href="/2019/01/09/%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E4%B8%87%E8%83%BDvip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/01/09/%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E4%B8%87%E8%83%BDvip%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="全网解析-支持站点"><a href="#全网解析-支持站点" class="headerlink" title="全网解析 支持站点"></a>全网解析 支持站点</h2><font color="#FF8000" size="3" face="楷体">奇艺视频 腾讯 优酷 土豆 芒果 乐视 搜狐 PPTV 华数TV 风行 咪咕 哔哩哔哩 ACfun 暴风 CCTV CNTV 范特西 9i广场舞 搜狐自媒体 M1905视频 看看视频 27盘 虎牙直播 全民直播 战旗直播 人人视频 爆米花 今日头条 天翼视频 糖豆视频 龙珠视频 快手视频<br>一直播 新浪视频 360小视频 熊猫TV 斗鱼TV 花椒直播 网易公开课 音悦台 秒拍网 美拍网 爱拍 凤凰视频 梨视频 微录客 人民微视频 17173视频 优米视频 m3u8 mp4视频 微博视频 YY视频 私有云资源</font><h5 id="https-cdn-yangju-vip-k-url-后面加上播放的地址即可"><a href="#https-cdn-yangju-vip-k-url-后面加上播放的地址即可" class="headerlink" title="https://cdn.yangju.vip/k/?url=后面加上播放的地址即可"></a><font size="3" face="楷体"><a href="https://cdn.yangju.vip/k/?url=后面加上播放的地址即可" target="_blank" rel="noopener">https://cdn.yangju.vip/k/?url=后面加上播放的地址即可</a></font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.yangju.vip/k/?url=</span><br><span class="line">https://jx.lache.me/cc/?url=</span><br><span class="line">https://api.653520.top/vip/?url=</span><br><span class="line">https://jx.ab33.top/vip/?url=</span><br><span class="line">https://vip.mpos.ren/v/?url=</span><br><span class="line">https://jx.000180.top/jx/?url=</span><br><span class="line">https://jx.km58.top/jx/?url=</span><br><span class="line">https://api.smq1.com/?url=</span><br><span class="line">https://jx.hezeshi.net/ce/jlexi.php?url=</span><br><span class="line">https://www.kkflv.com/?url=    //Btjson智能解析</span><br><span class="line">https://jx.618g.com/?url=    //618G解析</span><br></pre></td></tr></table></figure><h3 id="永久性，重要的是够稳定！而且CDN加速！！解析接口支持-URL模式"><a href="#永久性，重要的是够稳定！而且CDN加速！！解析接口支持-URL模式" class="headerlink" title="永久性，重要的是够稳定！而且CDN加速！！解析接口支持:URL模式"></a>永久性，重要的是够稳定！而且CDN加速！！解析接口支持:URL模式</h3>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Go的cron定时任务用法</title>
      <link href="/2018/12/27/Go%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95/"/>
      <url>/2018/12/27/Go%E7%9A%84cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="安装第三方库robfig-cron："><a href="#安装第三方库robfig-cron：" class="headerlink" title="安装第三方库robfig/cron："></a>安装第三方库robfig/cron：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/robfig/cron</span><br></pre></td></tr></table></figure><h2 id="应用：-每秒钟执行一次"><a href="#应用：-每秒钟执行一次" class="headerlink" title="应用： 每秒钟执行一次"></a>应用： 每秒钟执行一次</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/robfig/cron&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">i := 0</span><br><span class="line">c := cron.New()</span><br><span class="line">//秒 分 时 日 月 周</span><br><span class="line">spec := &quot;*/1 * * * * *&quot;</span><br><span class="line">c.AddFunc(spec, func() &#123;</span><br><span class="line">i++</span><br><span class="line">log.Println(&quot;execute per second&quot;, i)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line">select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其中注意select的用法：-golang的select的功能和-select-poll-epoll相似。也可以用for-实现"><a href="#其中注意select的用法：-golang的select的功能和-select-poll-epoll相似。也可以用for-实现" class="headerlink" title="其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现"></a>其中注意select的用法： golang的select的功能和 select, poll, epoll相似。也可以用for{}实现</h2>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go数学运算随机数</title>
      <link href="/2018/11/15/Go%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2018/11/15/Go%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>总是要有使用随机数的情况。这就需要使用math包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math/rand&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Println(&quot;My random number is&quot;,  rand.Intn(200))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行上面的代码就会发现每次返回的随机数是不变的。因为运行环境是没有发生变化的。<br>为了每次得到不同的随机数，就需要一个随机数种子。</p><p><font color="#FF8000" size="3" face="宋体">时间是不停的在发生变化的，利用time.Now().UnixNano()获得一个带纳秒的时间戳，<br>形成一个新源。然后随机数就可以有想要的效果了。</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math/rand&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    fmt.Println(&quot;My random number is&quot;, rand.Intn(200))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang的格式化输出</title>
      <link href="/2018/10/11/Golang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>/2018/10/11/Golang%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">普通占位符</span><br><span class="line">占位符     说明                           举例                   输出</span><br><span class="line">%v      相应值的默认格式。            Printf(&quot;%v&quot;, people)   &#123;zhangsan&#125;，</span><br><span class="line">%+v     打印结构体时，会添加字段名     Printf(&quot;%+v&quot;, people)  &#123;Name:zhangsan&#125;</span><br><span class="line">%#v     相应值的Go语法表示            Printf(&quot;#v&quot;, people)   main.Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br><span class="line">%T      相应值的类型的Go语法表示       Printf(&quot;%T&quot;, people)   main.Human</span><br><span class="line">%%      字面上的百分号，并非值的占位符  Printf(&quot;%%&quot;)            %</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">布尔占位符</span><br><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf(&quot;%t&quot;, true)       true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">整数占位符</span><br><span class="line">占位符     说明                                  举例                       输出</span><br><span class="line">%b      二进制表示                             Printf(&quot;%b&quot;, 5)             101</span><br><span class="line">%c      相应Unicode码点所表示的字符              Printf(&quot;%c&quot;, 0x4E2D)        中</span><br><span class="line">%d      十进制表示                             Printf(&quot;%d&quot;, 0x12)          18</span><br><span class="line">%o      八进制表示                             Printf(&quot;%d&quot;, 10)            12</span><br><span class="line">%q      单引号围绕的字符字面值，由Go语法安全地转义 Printf(&quot;%q&quot;, 0x4E2D)        &apos;中&apos;</span><br><span class="line">%x      十六进制表示，字母形式为小写 a-f         Printf(&quot;%x&quot;, 13)             d</span><br><span class="line">%X      十六进制表示，字母形式为大写 A-F         Printf(&quot;%x&quot;, 13)             D</span><br><span class="line">%U      Unicode格式：U+1234，等同于 &quot;U+%04X&quot;   Printf(&quot;%U&quot;, 0x4E2D)         U+4E2D</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮点数和复数的组成部分（实部和虚部）</span><br><span class="line">占位符     说明                              举例            输出</span><br><span class="line">%b      无小数部分的，指数为二的幂的科学计数法，</span><br><span class="line">        与 strconv.FormatFloat 的 &apos;b&apos; 转换格式一致。例如 -123456p-78</span><br><span class="line">%e      科学计数法，例如 -1234.456e+78        Printf(&quot;%e&quot;, 10.2)     1.020000e+01</span><br><span class="line">%E      科学计数法，例如 -1234.456E+78        Printf(&quot;%e&quot;, 10.2)     1.020000E+01</span><br><span class="line">%f      有小数点而无指数，例如 123.456        Printf(&quot;%f&quot;, 10.2)     10.200000</span><br><span class="line">%g      根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20)   10.2</span><br><span class="line">%G      根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串与字节切片</span><br><span class="line">占位符     说明                              举例                           输出</span><br><span class="line">%s      输出字符串表示（string类型或[]byte)   Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;))  Go语言</span><br><span class="line">%q      双引号围绕的字符串，由Go语法安全地转义  Printf(&quot;%q&quot;, &quot;Go语言&quot;)         &quot;Go语言&quot;</span><br><span class="line">%x      十六进制，小写字母，每字节两个字符      Printf(&quot;%x&quot;, &quot;golang&quot;)         676f6c616e67</span><br><span class="line">%X      十六进制，大写字母，每字节两个字符      Printf(&quot;%X&quot;, &quot;golang&quot;)         676F6C616E67</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针</span><br><span class="line">占位符         说明                      举例                             输出</span><br><span class="line">%p      十六进制表示，前缀 0x          Printf(&quot;%p&quot;, &amp;people)             0x4f57f0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">其它标记</span><br><span class="line">占位符      说明                             举例          输出</span><br><span class="line">+      总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 </span><br><span class="line">                                           Printf(&quot;%+q&quot;, &quot;中文&quot;)  &quot;\u4e2d\u6587&quot;</span><br><span class="line">-      在右侧而非左侧填充空格（左对齐该区域）</span><br><span class="line">#      备用格式：为八进制添加前导 0（%#o）      Printf(&quot;%#U&quot;, &apos;中&apos;)      U+4E2D</span><br><span class="line">       为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；</span><br><span class="line">       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；</span><br><span class="line">       如果是可打印字符，%U（%#U）会写出该字符的</span><br><span class="line">       Unicode 编码形式（如字符 x 会被打印成 U+0078 &apos;x&apos;）。</span><br><span class="line">&apos; &apos;    (空格)为数值中省略的正负号留出空白（% d）；</span><br><span class="line">       以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line">0      填充前导的0而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure><font color="#FF8000" size="4" face="微软雅黑"><br>golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。<br><br>宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。<br>操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。<br><br>对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。<br><br>%e 和 %f 的默认精度为6<br><br>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。<br><br>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。<br></font>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux awk命令详解</title>
      <link href="/2018/09/25/awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/09/25/awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>默认每行按空格或TAB分割：<code>awk &#39;{print $1,$4}&#39; log.txt</code></p><p>-F,指定分割字符：<code>awk -F : &#39;{print $1,$4}&#39; log.txt</code><br>   指定多个分割字符,先用:分割,然后再用,分割：<code>awk -F &#39;[:,]&#39; &#39;{print $1,$4}&#39; log.txt</code></p><p>-v,指定变量：<code>awk -v a=1 -v b=s &#39;{print $1,$1+a,$1b}&#39; log.txt</code></p><p>-f,调用awk脚本：<code>awk -f script.awk log.txt</code></p><p>//,纯字符匹配：<code>awk &#39;/dockerroot/&#39; /etc/passwd</code></p><p>!//,纯字符不匹配：<code>awk &#39;!/dockerroot/&#39; /etc/passwd</code></p><p>/|/,匹配a1或a2：<code>awk &#39;!/a1|a2/&#39; /etc/passwd</code></p><p>~//,字段值匹配：<code>awk &#39;$1~/root/&#39; /etc/passwd</code></p><p>!~//,字段值不匹配：<code>awk -F : &#39;$1!~/root/&#39; /etc/passwd</code></p><p>IF语句,必须用在{}中，且比较内容用()扩起来if…else…：<br><code>awk -F: &#39;{if($1~/root/) {print $1} else {print $2}}&#39; /etc/passwd</code>            </p><p>逻辑运算符：&amp;&amp;?|| </p><p>条件表达式：==   !=   &gt;   &gt;=  </p><p>while语句：<code>awk -F: &#39;BEGIN{i=1} {while(i&lt;8) print $i,i++}&#39; /etc/passwd</code></p><p>NF、NR：NF代表每行字段数，NR代表行号</p>]]></content>
      
      
      <categories>
          
          <category> Linux世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>openresty笔记</title>
      <link href="/2018/09/25/openresty%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/25/openresty%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>–启动命令：/usr/local/openresty/bin/openresty<br>–停止命令：/usr/local/openresty/bin/openresty -s stop<br>–重启命令：/usr/local/openresty/bin/openresty -s reload<br>–检验nginx配置是否正确：/usr/local/openresty/bin/openresty -t</p><p>开发时可以把server里面的location中的 lua_code_cache 设置为 off; 线上不要，代价太大。</p><p>ngx.say() 直接返回请求结果<br>ngx.req.read_body() 获取post body值<br>ngx.req.get_post_args() 获取post参数<br>ngx.req.get_uri_args() 获取url中参数</p><p>一个lua的表函数要有类似C++类函数的this指针（self）<br>用冒号(:)调用函数时，会默认传一个值(self)作为第一个参数;<br>用点(.)调用函数时，则没有；</p><pre><code>连。接。调。用。redis</code></pre><p>redis模块引用：在nginx主配置文件的http部分添加如下配置 ，其中”;;”表示默认搜索路径。<br>lua_package_path “/usr/local/openresty/lualib/resty/?.lua;;”;      #lua 模块<br>lua_package_cpath “yourpath/?.so;;”;                                      #c模块</p><p>local redis = require(“resty.redis”)                           #导入 resty.redis 模块<br>local red = redis:new()                                           #实例化 redis 对象<br>red:set_timeout(1000)                                           #设置超时（毫秒）<br>local ok, err = red:connect(“127.0.0.1”, 6379)         #连接到服务器<br>local ok, err = red:auth(“yourpasswd”)                    #验证（如果要验证）<br>local ok, err = red:set_keepalive(1000, 100)            #将连接添加到连接池中<br>local ok, err = red:set(“dog”, “an animal”)               #redis的set操作<br>local res, err = red:get(“dog”)                                 #redis的get操作<br>red:close()                                                             #关闭连接,如果使用连接池就不需要关闭</p><p>启用连接池需要开启 lua_code_cache on<br>测试连接池时，线程数需要小于set_keepalive中的第二个参数（即连接数）</p>]]></content>
      
      
      <categories>
          
          <category> Linux世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openresty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7.3编译安装go1.8.1</title>
      <link href="/2018/09/25/CentOS7.3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1.8.1/"/>
      <url>/2018/09/25/CentOS7.3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1.8.1/</url>
      
        <content type="html"><![CDATA[<p>go1.8.1下载地址<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>，这里下载go1.8.1.src.tar.gz和go1.4.3.src.tar.gz，下来以后算下md5哈希和官网比对下，以免被加盐；</p><p><font color="red" size="3" face="微软雅黑">go1.4以上版本安装的时候需先安装下1.4；要么会报类似下面的错：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##### Building Go bootstrap tool.</span><br><span class="line">cmd/dist</span><br><span class="line">ERROR: Cannot find /root/go1.4/bin/go.</span><br><span class="line">Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4.</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">开始安装：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc glibc-devel -y</span><br><span class="line">tar -C /root/ -xvf go1.4.3.src.tar.gz</span><br><span class="line">mv /root/go/ /root/go1.4</span><br><span class="line">cd /root/go1.4/src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">约１分钟左右安装完成，设置下环境变量并重新加载</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export PATH=$PATH:/root/go1.4/bin&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo &quot;export GOROOT=/root/go1.4&quot; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">使用go version查看版本已经是go1.4.3了</font><br><img src="/img/2485282189.png" width="548"></p><p><font color="gray" size="5" face="楷体">开始安装go1.8.1</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local/ -xvf go1.8.1.src.tar.gz</span><br><span class="line">cd /usr/local/go/src/</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">安装完成以后，清除掉之前添加的/etc/profile里面的环境变量信息，增加如下配置</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/go-projects</span><br></pre></td></tr></table></figure></p><p><font color="gray" size="5" face="楷体">重新加载配置</font><br><code>source /etc/profile</code></p><p><font color="gray" size="5" face="楷体">查看版本go version,已经是1.8.1了</font><br><img src="/img/3683651371.png" height="86"></p><p><font color="gray" size="5" face="楷体">创建go的hello world程序：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存为hello.go<br>直接运行 go run hello.go<br>返回hello，world！</p><p><font color="#FF8000" size="5" face="楷体">至此，go1.8.1安装完毕！</font><br>或者直接使用编译好的包：go1.10.1.linux-amd64.tar.gz<br>下载go<br>$wget <a href="https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz" target="_blank" rel="noopener">https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz</a><br>$tar -xvf go1.10.1.linux-amd64.tar.gz<br>设置环境变量<br>$vim /etc/profile<br>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/data/work/gopath</span><br><span class="line">export GOBIN=$GOPATH/bin</span><br><span class="line">export GOROOT=/data/work/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin:$GOBIN</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>$GOPATH工作目录结构，约定有三个子目录（需要自行创建）：<br>src ——存放源代码文件<br>pkg——存放编译后的文件<br>bin ——存放编译后的可执行文件<br>测试环境:<br>创建目录 /data/work/gopath/src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$mkdir helloworld</span><br><span class="line">$cd helloworld</span><br><span class="line">$vim main.go</span><br></pre></td></tr></table></figure></p><p>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux上安装GO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go操作mysql建表问题的解决办法</title>
      <link href="/2018/09/25/Go%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/09/25/Go%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF8000" size="4" face="楷体">table.sql 文件内容如下</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;,</span><br><span class="line">  `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="4" face="楷体">go 代码如下：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func createTable() (err error) &#123;</span><br><span class="line">    host := &quot;127.0.0.1&quot;</span><br><span class="line">    port := &quot;3306&quot;</span><br><span class="line">    user := &quot;root&quot;</span><br><span class="line">    pass := &quot;admin&quot;</span><br><span class="line">    name := &quot;test&quot;</span><br><span class="line">    sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;);</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    sqlTable := string(sqlBytes);</span><br><span class="line">    fmt.Println(sqlTable)</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">    _, err = db.Exec(sqlTable)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="4" face="楷体">执行，出错：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right </span><br><span class="line">syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>刚开始是以为 sql 语句有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql语句的问题。<br>查找资料才知道原因 默认是不能在同时执行两条 sql 语句的</p><p><font color="#FF8000" size="4" face="楷体">解决办法：</font><br>1.将 多条 sql 语句拆开，每个语句单独执行 db.Exec()<br>2.查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下 (增加了 &amp;multiStatements=true 参数)<br><code></code>db, err := sql.Open(“mysql”, user+”:”+pass+”@tcp(“+host+”:”+port+”)/“+name+”?charset=utf8&amp;multiStatements=true”)</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang操作mysql使用案例</title>
      <link href="/2018/09/25/Golang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2018/09/25/Golang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;database/sql&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type DbWorker struct &#123;</span><br><span class="line">Dsn      string</span><br><span class="line">Db       *sql.DB</span><br><span class="line">UserInfo userTB</span><br><span class="line">&#125;</span><br><span class="line">type userTB struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name sql.NullString</span><br><span class="line">Age  sql.NullInt64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var err error</span><br><span class="line">dbw := DbWorker&#123;</span><br><span class="line">Dsn: &quot;root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4&quot;,</span><br><span class="line">&#125;</span><br><span class="line">dbw.Db, err = sql.Open(&quot;mysql&quot;, dbw.Dsn)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dbw.Db.Close()</span><br><span class="line"></span><br><span class="line">dbw.insertData()</span><br><span class="line">dbw.queryData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dbw *DbWorker) insertData() &#123;</span><br><span class="line">stmt, _ := dbw.Db.Prepare(`INSERT INTO user (name, age) VALUES (?, ?)`)</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">ret, err := stmt.Exec(&quot;xys&quot;, 23)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;insert data error: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if LastInsertId, err := ret.LastInsertId(); nil == err &#123;</span><br><span class="line">fmt.Println(&quot;LastInsertId:&quot;, LastInsertId)</span><br><span class="line">&#125;</span><br><span class="line">if RowsAffected, err := ret.RowsAffected(); nil == err &#123;</span><br><span class="line">fmt.Println(&quot;RowsAffected:&quot;, RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dbw *DbWorker) QueryDataPre() &#123;</span><br><span class="line">dbw.UserInfo = userTB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">func (dbw *DbWorker) queryData() &#123;</span><br><span class="line">stmt, _ := dbw.Db.Prepare(`SELECT * From user where age &gt;= ? AND age &lt; ?`)</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">dbw.QueryDataPre()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(20, 30)</span><br><span class="line">defer rows.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;insert data error: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if !dbw.UserInfo.Name.Valid &#123;</span><br><span class="line">dbw.UserInfo.Name.String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">if !dbw.UserInfo.Age.Valid &#123;</span><br><span class="line">dbw.UserInfo.Age.Int64 = 0</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;get data, id: &quot;, dbw.UserInfo.Id, &quot; name: &quot;, dbw.UserInfo.Name.String, &quot; age: &quot;, int(dbw.UserInfo.Age.Int64))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = rows.Err()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Python3的Flask教程中文版</title>
      <link href="/2018/09/24/%E5%9F%BA%E4%BA%8EPython3%E7%9A%84Flask%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2018/09/24/%E5%9F%BA%E4%BA%8EPython3%E7%9A%84Flask%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AHello%2C%20World!.md" target="_blank" rel="noopener">第一章：Hello, World!</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF.md" target="_blank" rel="noopener">第二章：模板</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AWeb%E8%A1%A8%E5%8D%95.md" target="_blank" rel="noopener">第三章：Web表单</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93.md" target="_blank" rel="noopener">第四章：数据库</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.md" target="_blank" rel="noopener">第五章：用户登录</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E5%92%8C%E5%A4%B4%E5%83%8F.md" target="_blank" rel="noopener">第六章：个人主页和头像</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">第七章：错误处理</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E7%B2%89%E4%B8%9D.md" target="_blank" rel="noopener">第八章：粉丝</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E5%88%86%E9%A1%B5.md" target="_blank" rel="noopener">第九章：分页</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%82%AE%E4%BB%B6%E6%94%AF%E6%8C%81.md" target="_blank" rel="noopener">第十章：邮件支持</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BE%8E%E5%8C%96.md" target="_blank" rel="noopener">第十一章：美化</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.md" target="_blank" rel="noopener">第十二章：日期和时间</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96.md" target="_blank" rel="noopener">第十三章：国际化和本地化</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9AAjax.md" target="_blank" rel="noopener">第十四章：Ajax</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BC%98%E5%8C%96%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener">第十五章：优化应用结构</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2.md" target="_blank" rel="noopener">第十六章：全文搜索</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9ALinux%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十七章：Linux上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%EF%BC%9AHeroku%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十八章：Heroku上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9ADocker%E5%AE%B9%E5%99%A8%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2.md" target="_blank" rel="noopener">第十九章：Docker容器上的部署</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8A%A0%E7%82%B9JavaScript%E9%AD%94%E6%B3%95.md" target="_blank" rel="noopener">第二十章：加点JavaScript魔法</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E9%80%9A%E7%9F%A5.md" target="_blank" rel="noopener">第二十一章：用户通知</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A.md" target="_blank" rel="noopener">第二十二章：后台作业</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88API%EF%BC%89.md" target="_blank" rel="noopener">第二十三章：应用程序编程接口（API）</a></p>]]></content>
      
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习中的一些记录，随心记</title>
      <link href="/2018/09/24/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%EF%BC%8C%E9%9A%8F%E5%BF%83%E8%AE%B0/"/>
      <url>/2018/09/24/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%EF%BC%8C%E9%9A%8F%E5%BF%83%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Python扩展包大全：https-www-lfd-uci-edu-gohlke-pythonlibs"><a href="#Python扩展包大全：https-www-lfd-uci-edu-gohlke-pythonlibs" class="headerlink" title="Python扩展包大全：https://www.lfd.uci.edu/~gohlke/pythonlibs"></a><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs" target="_blank" rel="noopener">Python扩展包大全</a>：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs</a></h2><h2 id="docker删除none标签镜像："><a href="#docker删除none标签镜像：" class="headerlink" title="docker删除none标签镜像："></a>docker删除none标签镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images|grep none|awk <span class="string">'&#123;print $3 &#125;'</span>|xargs docker rmi</span><br></pre></td></tr></table></figure><h2 id="go使用reflect-TypeOf-x-判断x的数据类型：import-“reflect”"><a href="#go使用reflect-TypeOf-x-判断x的数据类型：import-“reflect”" class="headerlink" title="go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”"></a>go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”</h2><h2 id="查看当前目录下各文件夹占用空间，深度1："><a href="#查看当前目录下各文件夹占用空间，深度1：" class="headerlink" title="查看当前目录下各文件夹占用空间，深度1："></a>查看当前目录下各文件夹占用空间，深度1：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du -h --max-depth=1</span><br></pre></td></tr></table></figure><h2 id="Golang-在windows下编译Linux下可执行文件-一定要用cmd-，在程序根目录下设置编译环境："><a href="#Golang-在windows下编译Linux下可执行文件-一定要用cmd-，在程序根目录下设置编译环境：" class="headerlink" title="Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境："></a>Golang 在windows下编译Linux下可执行文件(一定要用cmd)，在程序根目录下设置编译环境：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux  </span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="Linux后台运行并且不生成nohup-out文件："><a href="#Linux后台运行并且不生成nohup-out文件：" class="headerlink" title="Linux后台运行并且不生成nohup.out文件："></a>Linux后台运行并且不生成nohup.out文件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./程序名 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="抓包命令-："><a href="#抓包命令-：" class="headerlink" title="抓包命令 ："></a>抓包命令 ：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -iany host 127.0.0.1 -XNnn </span><br><span class="line">tcpdump -iany port 80 -XNnn</span><br></pre></td></tr></table></figure><h2 id="php容器中添加pdo-mysql扩展模块"><a href="#php容器中添加pdo-mysql扩展模块" class="headerlink" title="php容器中添加pdo_mysql扩展模块"></a>php容器中添加pdo_mysql扩展模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-php-ext-install pdo_mysql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随心笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 烂笔头 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang中json、map、struct互相转换</title>
      <link href="/2018/09/24/Golang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/09/24/Golang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF8000" size="5" face="楷体">json转struct</font><br>使用json.Unmarshal时，结构体的每一项必须是导出项（import field）。也就是说结构体的key对应的首字母必须大写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;encoding/json&quot;</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">   Name string `json:&quot;name_tile&quot;`</span><br><span class="line">   Age int `json:&quot;age_size&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func JsonToStructDemo() &#123;</span><br><span class="line">   jsonStr := `</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;name_tile&quot;: &quot;liuXX&quot;,</span><br><span class="line">      &quot;age_size&quot;: 12</span><br><span class="line">   &#125;</span><br><span class="line">   `</span><br><span class="line">   var people People</span><br><span class="line">   json.Unmarshal([]byte(jsonStr), &amp;people)</span><br><span class="line">   fmt.Println(people)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   JsonToStructDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">struct转json</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;testing&quot;</span><br><span class="line">   &quot;encoding/json&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People struct &#123;</span><br><span class="line">   Name string `json:&quot;name_tILE&quot;`</span><br><span class="line">   Age int `json:&quot;AGE_SIZE&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func TestStructToJson(t *testing.T) &#123;</span><br><span class="line">   p := People&#123;</span><br><span class="line">      Name: &quot;Liu xx&quot;,</span><br><span class="line">      Age: 18,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t.Logf(&quot;Person 结构体打印结果:%v&quot;, p)</span><br><span class="line"></span><br><span class="line">   //Person 结构体转换为对应的 Json</span><br><span class="line">   jsonBytes, err := json.Marshal(p)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">json转map</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func TestJsonToMap(t *testing.T) &#123;</span><br><span class="line">   jsonStr := `</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Liu XX&quot;,</span><br><span class="line">      &quot;age&quot;: 18</span><br><span class="line">   &#125;</span><br><span class="line">   `</span><br><span class="line">   var mapResult map[string]interface&#123;&#125;</span><br><span class="line">   //使用 json.Unmarshal(data []byte, v interface&#123;&#125;)进行转换,返回 error 信息</span><br><span class="line">   if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Log(mapResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">map转json</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func TestMapToJson(t *testing.T) &#123;</span><br><span class="line">   mapInstance := make(map[string]interface&#123;&#125;)</span><br><span class="line">   mapInstance[&quot;Name&quot;] = &quot;Liu xx&quot;</span><br><span class="line">   mapInstance[&quot;Age&quot;] = 18</span><br><span class="line">   mapInstance[&quot;Address&quot;] = &quot;广东 深圳&quot;</span><br><span class="line"></span><br><span class="line">   jsonStr, err := json.Marshal(mapInstance)</span><br><span class="line"></span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t.Logf(&quot;TestMapToJson 得到 json 字符串内容:%s&quot;, jsonStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">map转struct</font><br>map转换struct要用第三方库提供的方法：$ go get github.com/goinggo/mapstructure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestMapToStruct(t *testing.T) &#123;</span><br><span class="line">   mapInstance := make(map[string]interface&#123;&#125;)</span><br><span class="line">   mapInstance[&quot;Name&quot;] = &quot;liang637210&quot;</span><br><span class="line">   mapInstance[&quot;Age&quot;] = 28</span><br><span class="line"></span><br><span class="line">   var people People</span><br><span class="line">   //将 map 转换为指定的结构体</span><br><span class="line">   if err := mapstructure.Decode(mapInstance, &amp;people); err != nil &#123;</span><br><span class="line">      t.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="#FF8000" size="5" face="楷体">struct转map</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">   Id int `json:&quot;id&quot;`</span><br><span class="line">   Username string `json:&quot;username&quot;`</span><br><span class="line">   Password string `json:&quot;password&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StructToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123;</span><br><span class="line">   t := reflect.TypeOf(obj)</span><br><span class="line">   v := reflect.ValueOf(obj)</span><br><span class="line"></span><br><span class="line">   var data = make(map[string]interface&#123;&#125;)</span><br><span class="line">   for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">      data[t.Field(i).Name] = v.Field(i).Interface()</span><br><span class="line">&#125;</span><br><span class="line">   return data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestStructToMap(t *testing.T) &#123;</span><br><span class="line">   user := User&#123;5, &quot;zhangsan&quot;, &quot;password&quot;&#125;</span><br><span class="line">   data := StructToMap(user)</span><br><span class="line">   t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go记录 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
