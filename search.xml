<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS7.3编译安装go1.8.1]]></title>
    <url>%2F2018%2F09%2F25%2FCentOS7-3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85go1-8-1%2F</url>
    <content type="text"><![CDATA[go1.8.1下载地址https://golang.org/dl/，这里下载go1.8.1.src.tar.gz和go1.4.3.src.tar.gz，下来以后算下md5哈希和官网比对下，以免被加盐； go1.4以上版本安装的时候需先安装下1.4；要么会报类似下面的错：1234##### Building Go bootstrap tool.cmd/distERROR: Cannot find /root/go1.4/bin/go.Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4. 开始安装：12345yum install gcc glibc-devel -ytar -C /root/ -xvf go1.4.3.src.tar.gzmv /root/go/ /root/go1.4cd /root/go1.4/src./all.bash 约１分钟左右安装完成，设置下环境变量并重新加载123echo &quot;export PATH=$PATH:/root/go1.4/bin&quot; &gt;&gt; /etc/profileecho &quot;export GOROOT=/root/go1.4&quot; &gt;&gt; /etc/profilesource /etc/profile 使用go version查看版本已经是go1.4.3了 开始安装go1.8.1123tar -C /usr/local/ -xvf go1.8.1.src.tar.gzcd /usr/local/go/src/./all.bash 安装完成以后，清除掉之前添加的/etc/profile里面的环境变量信息，增加如下配置123export PATH=$PATH:/usr/local/go/binexport GOROOT=/usr/local/goexport GOPATH=/usr/local/go-projects 重新加载配置source /etc/profile 查看版本go version,已经是1.8.1了 创建go的hello world程序：1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 保存为hello.go直接运行 go run hello.go返回hello，world！ 至此，go1.8.1安装完毕！或者直接使用编译好的包：go1.10.1.linux-amd64.tar.gz下载go$wget https://studygolang.com/dl/golang/go1.10.1.linux-amd64.tar.gz$tar -xvf go1.10.1.linux-amd64.tar.gz设置环境变量$vim /etc/profile添加12345export GOPATH=/data/work/gopathexport GOBIN=$GOPATH/binexport GOROOT=/data/work/goexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin:$GOBINsource /etc/profile $GOPATH工作目录结构，约定有三个子目录（需要自行创建）：src ——存放源代码文件pkg——存放编译后的文件bin ——存放编译后的可执行文件测试环境:创建目录 /data/work/gopath/src123$mkdir helloworld$cd helloworld$vim main.go 输入:1234567package main import &quot;fmt&quot; func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Linux上安装GO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux awk命令详解]]></title>
    <url>%2F2018%2F09%2F25%2Fawk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[默认每行按空格或TAB分割：awk &#39;{print $1,$4}&#39; log.txt -F,指定分割字符：awk -F : &#39;{print $1,$4}&#39; log.txt 指定多个分割字符,先用:分割,然后再用,分割：awk -F &#39;[:,]&#39; &#39;{print $1,$4}&#39; log.txt -v,指定变量：awk -v a=1 -v b=s &#39;{print $1,$1+a,$1b}&#39; log.txt -f,调用awk脚本：awk -f script.awk log.txt //,纯字符匹配：awk &#39;/dockerroot/&#39; /etc/passwd !//,纯字符不匹配：awk &#39;!/dockerroot/&#39; /etc/passwd /|/,匹配a1或a2：awk &#39;!/a1|a2/&#39; /etc/passwd ~//,字段值匹配：awk &#39;$1~/root/&#39; /etc/passwd !~//,字段值不匹配：awk -F : &#39;$1!~/root/&#39; /etc/passwd IF语句,必须用在{}中，且比较内容用()扩起来if…else…：awk -F: &#39;{if($1~/root/) {print $1} else {print $2}}&#39; /etc/passwd 逻辑运算符：&amp;&amp;?|| 条件表达式：== != &gt; &gt;= while语句：awk -F: &#39;BEGIN{i=1} {while(i&lt;8) print $i,i++}&#39; /etc/passwd NF、NR：NF代表每行字段数，NR代表行号]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openresty笔记]]></title>
    <url>%2F2018%2F09%2F25%2Fopenresty%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[–启动命令：/usr/local/openresty/bin/openresty–停止命令：/usr/local/openresty/bin/openresty -s stop–重启命令：/usr/local/openresty/bin/openresty -s reload–检验nginx配置是否正确：/usr/local/openresty/bin/openresty -t 开发时可以把server里面的location中的 lua_code_cache 设置为 off; 线上不要，代价太大。 ngx.say() 直接返回请求结果ngx.req.read_body() 获取post body值ngx.req.get_post_args() 获取post参数ngx.req.get_uri_args() 获取url中参数 一个lua的表函数要有类似C++类函数的this指针（self）用冒号(:)调用函数时，会默认传一个值(self)作为第一个参数;用点(.)调用函数时，则没有； 连。接。调。用。redis redis模块引用：在nginx主配置文件的http部分添加如下配置 ，其中”;;”表示默认搜索路径。lua_package_path “/usr/local/openresty/lualib/resty/?.lua;;”; #lua 模块lua_package_cpath “yourpath/?.so;;”; #c模块 local redis = require(“resty.redis”) #导入 resty.redis 模块local red = redis:new() #实例化 redis 对象red:set_timeout(1000) #设置超时（毫秒）local ok, err = red:connect(“127.0.0.1”, 6379) #连接到服务器local ok, err = red:auth(“yourpasswd”) #验证（如果要验证）local ok, err = red:set_keepalive(1000, 100) #将连接添加到连接池中local ok, err = red:set(“dog”, “an animal”) #redis的set操作local res, err = red:get(“dog”) #redis的get操作red:close() #关闭连接,如果使用连接池就不需要关闭 启用连接池需要开启 lua_code_cache on测试连接池时，线程数需要小于set_keepalive中的第二个参数（即连接数）]]></content>
      <categories>
        <category>Linux世界</category>
      </categories>
      <tags>
        <tag>Openresty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go操作mysql建表问题的解决办法]]></title>
    <url>%2F2018%2F09%2F25%2FGo%E6%93%8D%E4%BD%9Cmysql%E5%BB%BA%E8%A1%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[table.sql 文件内容如下123456DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;, `name` varchar(30) NOT NULL COMMENT &apos;姓名&apos;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; go 代码如下：1234567891011121314151617181920212223func createTable() (err error) &#123; host := &quot;127.0.0.1&quot; port := &quot;3306&quot; user := &quot;root&quot; pass := &quot;admin&quot; name := &quot;test&quot; sqlBytes, err = ioutil.ReadFile(&quot;docs/databases/table.sql&quot;); if err != nil &#123; return &#125; sqlTable := string(sqlBytes); fmt.Println(sqlTable) db, err := sql.Open(&quot;mysql&quot;, user+&quot;:&quot;+pass+&quot;@tcp(&quot;+host+&quot;:&quot;+port+&quot;)/&quot;+name+&quot;?charset=utf8&quot;) if err != nil &#123; return &#125; defer db.Close() _, err = db.Exec(sqlTable) if err != nil &#123; return &#125; return nil&#125; 执行，出错：12Error 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;CREATE TABLE `user` (`user_id` int(11) NOT NULL AUTO_INCREMENT COMMEN&apos; at line 1 刚开始是以为 sql 语句有问题，所以将 sql 语句直接粘贴到 mysql 命令行执行，成功。所以不是 sql语句的问题。查找资料才知道原因 默认是不能在同时执行两条 sql 语句的 解决办法：1.将 多条 sql 语句拆开，每个语句单独执行 db.Exec()2.查看 go-sql-driver 的文档，发现可以支持一条语句多条 sql 执行。修改代码如下 (增加了 &amp;multiStatements=true 参数)db, err := sql.Open(“mysql”, user+”:”+pass+”@tcp(“+host+”:”+port+”)/“+name+”?charset=utf8&amp;multiStatements=true”)]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang操作mysql使用案例]]></title>
    <url>%2F2018%2F09%2F25%2FGolang%E6%93%8D%E4%BD%9Cmysql%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)type DbWorker struct &#123; Dsn string Db *sql.DB UserInfo userTB&#125;type userTB struct &#123; Id int Name sql.NullString Age sql.NullInt64&#125;func main() &#123; var err error dbw := DbWorker&#123; Dsn: &quot;root:123456@tcp(localhost:3306)/sqlx_db?charset=utf8mb4&quot;, &#125; dbw.Db, err = sql.Open(&quot;mysql&quot;, dbw.Dsn) if err != nil &#123; panic(err) return &#125; defer dbw.Db.Close() dbw.insertData() dbw.queryData()&#125;func (dbw *DbWorker) insertData() &#123; stmt, _ := dbw.Db.Prepare(`INSERT INTO user (name, age) VALUES (?, ?)`) defer stmt.Close() ret, err := stmt.Exec(&quot;xys&quot;, 23) if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; if LastInsertId, err := ret.LastInsertId(); nil == err &#123; fmt.Println(&quot;LastInsertId:&quot;, LastInsertId) &#125; if RowsAffected, err := ret.RowsAffected(); nil == err &#123; fmt.Println(&quot;RowsAffected:&quot;, RowsAffected) &#125;&#125;func (dbw *DbWorker) QueryDataPre() &#123; dbw.UserInfo = userTB&#123;&#125;&#125;func (dbw *DbWorker) queryData() &#123; stmt, _ := dbw.Db.Prepare(`SELECT * From user where age &gt;= ? AND age &lt; ?`) defer stmt.Close() dbw.QueryDataPre() rows, err := stmt.Query(20, 30) defer rows.Close() if err != nil &#123; fmt.Printf(&quot;insert data error: %v\n&quot;, err) return &#125; for rows.Next() &#123; rows.Scan(&amp;dbw.UserInfo.Id, &amp;dbw.UserInfo.Name, &amp;dbw.UserInfo.Age) if err != nil &#123; fmt.Printf(err.Error()) continue &#125; if !dbw.UserInfo.Name.Valid &#123; dbw.UserInfo.Name.String = &quot;&quot; &#125; if !dbw.UserInfo.Age.Valid &#123; dbw.UserInfo.Age.Int64 = 0 &#125; fmt.Println(&quot;get data, id: &quot;, dbw.UserInfo.Id, &quot; name: &quot;, dbw.UserInfo.Name.String, &quot; age: &quot;, int(dbw.UserInfo.Age.Int64)) &#125; err = rows.Err() if err != nil &#123; fmt.Printf(err.Error()) &#125;&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习中的一些记录，随心记]]></title>
    <url>%2F2018%2F09%2F24%2F%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python扩展包大全：https://www.lfd.uci.edu/~gohlke/pythonlibsdocker删除none标签镜像：1$ docker images|grep none|awk '&#123;print $3 &#125;'|xargs docker rmi go使用reflect.TypeOf(x)判断x的数据类型：import “reflect”查看当前目录下各文件夹占用空间，深度1：1$ du -h --max-depth=1]]></content>
      <categories>
        <category>随心笔记</category>
      </categories>
      <tags>
        <tag>烂笔头</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python3的Flask教程中文版]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%9F%BA%E4%BA%8E%20Python%203%20%E7%9A%84%20Flask%20%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88%2F</url>
    <content type="text"><![CDATA[第一章：Hello, World!第二章：模板第三章：Web表单第四章：数据库第五章：用户登录第六章：个人主页和头像第七章：错误处理第八章：粉丝第九章：分页第十章：邮件支持第十一章：美化第十二章：日期和时间第十三章：国际化和本地化第十四章：Ajax第十五章：优化应用结构第十六章：全文搜索第十七章：Linux上的部署第十八章：Heroku上的部署第十九章：Docker容器上的部署第二十章：加点JavaScript魔法第二十一章：用户通知第二十二章：后台作业第二十三章：应用程序编程接口（API）]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Flask教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中json、map、struct互相转换]]></title>
    <url>%2F2018%2F09%2F24%2FGolang%E4%B8%ADjson%E3%80%81map%E3%80%81struct%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[json转struct使用json.Unmarshal时，结构体的每一项必须是导出项（import field）。也就是说结构体的key对应的首字母必须大写。123456789101112131415161718192021222324252627package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type People struct &#123; Name string `json:&quot;name_tile&quot;` Age int `json:&quot;age_size&quot;`&#125;func JsonToStructDemo() &#123; jsonStr := ` &#123; &quot;name_tile&quot;: &quot;liuXX&quot;, &quot;age_size&quot;: 12 &#125; ` var people People json.Unmarshal([]byte(jsonStr), &amp;people) fmt.Println(people)&#125;func main() &#123; JsonToStructDemo()&#125; struct转json12345678910111213141516171819202122232425262728package testimport ( &quot;testing&quot; &quot;encoding/json&quot;)type People struct &#123; Name string `json:&quot;name_tILE&quot;` Age int `json:&quot;AGE_SIZE&quot;`&#125;func TestStructToJson(t *testing.T) &#123; p := People&#123; Name: &quot;Liu xx&quot;, Age: 18, &#125; t.Logf(&quot;Person 结构体打印结果:%v&quot;, p) //Person 结构体转换为对应的 Json jsonBytes, err := json.Marshal(p) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;转换为 json 串打印结果:%s&quot;, string(jsonBytes))&#125; json转map1234567891011121314func TestJsonToMap(t *testing.T) &#123; jsonStr := ` &#123; &quot;name&quot;: &quot;Liu XX&quot;, &quot;age&quot;: 18 &#125; ` var mapResult map[string]interface&#123;&#125; //使用 json.Unmarshal(data []byte, v interface&#123;&#125;)进行转换,返回 error 信息 if err := json.Unmarshal([]byte(jsonStr), &amp;mapResult); err != nil &#123; t.Fatal(err) &#125; t.Log(mapResult)&#125; map转json1234567891011121314func TestMapToJson(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;Liu xx&quot; mapInstance[&quot;Age&quot;] = 18 mapInstance[&quot;Address&quot;] = &quot;广东 深圳&quot; jsonStr, err := json.Marshal(mapInstance) if err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;TestMapToJson 得到 json 字符串内容:%s&quot;, jsonStr)&#125; map转structmap转换struct要用第三方库提供的方法：$ go get github.com/goinggo/mapstructure123456789101112func TestMapToStruct(t *testing.T) &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[&quot;Name&quot;] = &quot;liang637210&quot; mapInstance[&quot;Age&quot;] = 28 var people People //将 map 转换为指定的结构体 if err := mapstructure.Decode(mapInstance, &amp;people); err != nil &#123; t.Fatal(err) &#125; t.Logf(&quot;map2struct后得到的 struct 内容为:%v&quot;, people)&#125; struct转map12345678910111213141516171819202122type User struct &#123; Id int `json:&quot;id&quot;` Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;`&#125;func StructToMap(obj interface&#123;&#125;) map[string]interface&#123;&#125; &#123; t := reflect.TypeOf(obj) v := reflect.ValueOf(obj) var data = make(map[string]interface&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; data[t.Field(i).Name] = v.Field(i).Interface()&#125; return data&#125;func TestStructToMap(t *testing.T) &#123; user := User&#123;5, &quot;zhangsan&quot;, &quot;password&quot;&#125; data := StructToMap(user) t.Logf(&quot;struct2map得到的map内容为:%v&quot;, data)&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Go记录</tag>
      </tags>
  </entry>
</search>
